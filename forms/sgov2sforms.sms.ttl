# baseURI: http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms
# imports: http://onto.fel.cvut.cz/ontologies/form-layout
# imports: http://onto.fel.cvut.cz/ontologies/form-lib
# imports: http://onto.fel.cvut.cz/ontologies/form-metadata
# imports: http://onto.fel.cvut.cz/ontologies/lib/sm-module-adapter
# imports: http://onto.fel.cvut.cz/ontologies/lib/spin-function
# imports: http://onto.fel.cvut.cz/ontologies/s-pipes-lib
# imports: https://slovník.gov.cz/základní/model

@prefix : <http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms/> .
@prefix a-popis-dat: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/> .
@prefix a-popis-dat-pojem: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/pojem/> .
@prefix dc: <http://purl.org/dc/terms/> .
@prefix dce: <http://purl.org/dc/elements/1.1/> .
@prefix doc: <http://onto.fel.cvut.cz/ontologies/documentation/> .
@prefix fl: <http://onto.fel.cvut.cz/ontologies/form-lib/> .
@prefix fm: <http://onto.fel.cvut.cz/ontologies/form-metadata/> .
@prefix form: <http://onto.fel.cvut.cz/ontologies/form/> .
@prefix form-ecc-lib: <http://onto.fel.cvut.cz/ontologies/aviation/eccairs-form-lib/> .
@prefix form-lt: <http://onto.fel.cvut.cz/ontologies/form-layout/> .
@prefix kbss-module: <http://onto.fel.cvut.cz/ontologies/lib/module/> .
@prefix kbss-spif: <http://onto.fel.cvut.cz/ontologies/lib/spin-function/> .
@prefix km-rdf4j: <http://onto.fel.cvut.cz/ontologies/lib/module/rdf4j/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix termit: <http://onto.fel.cvut.cz/ontologies/application/termit/> .
@prefix termit-pojem: <http://onto.fel.cvut.cz/ontologies/application/termit/pojem/> .
@prefix v-sgov-pojem: <https://slovník.gov.cz/veřejný-sektor/pojem/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix z-sgov: <https://slovník.gov.cz/základní/> .
@prefix z-sgov-pojem: <https://slovník.gov.cz/základní/pojem/> .

<http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms>
  a owl:Ontology ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-layout> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-lib> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-metadata> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/lib/sm-module-adapter> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/lib/spin-function> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/s-pipes-lib> ;
  owl:imports z-sgov:model ;
.
:attach-descriptions
  a sml:ApplyConstruct ;
  sm:next :attach-value-types ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# create descriptions
CONSTRUCT {
    ?q dce:description ?description .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    OPTIONAL {
        ?entity skos:definition ?definition .
    } .
    OPTIONAL {
        ?entity skos:scopeNote ?scopeNote .
    } .
    BIND (COALESCE(?definition, ?scopeNote) AS ?description)
}""" ;
    ] ;
  sml:replace false ;
.
:attach-possible-values-hook
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?question form:has-possible-values-query ?downloadString .
    ?question form-lt:has-layout-class \"type-ahead\" .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
        ?entity fm:external true .
    } .
    ?question form:has-question-origin ?entity .
    BIND (CONCAT(str(?sgovServiceUrl), \"&query=\") AS ?dowloadPrefix) .
    BIND (REPLACE(?possibleValuesQueryTemplate, \"XXXXX\", str(?entity)) AS ?downloadSuffixRaw) .
    BIND (ENCODE_FOR_URI(?downloadSuffixRaw) AS ?downloadSuffix)
    BIND (CONCAT(?dowloadPrefix, ?downloadSuffix) AS ?downloadString)
}""" ;
    ] ;
  sml:replace true ;
.
:attach-value-types
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# boolean
CONSTRUCT {
    ?q form-lt:has-layout-class \"checkbox\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:boolean .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# date
CONSTRUCT {
    ?q form-lt:has-layout-class \"masked-input\" .
    ?q form:has-input-mask \"DD/MM/YYYY\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:date .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# datetime
CONSTRUCT {
    ?q form-lt:has-layout-class \"datetime\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:datetime .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# number
CONSTRUCT {
    ?q form-lt:has-layout-class \"number\" .
    ?q form:has-datatype xsd:int .
    ?q xsd:maxInclusive 100 .
    ?q xsd:minInclusive 0 .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:number .
}""" ;
    ] ;
  sml:replace false ;
.
:bind-execution-id
  a sml:BindWithConstant ;
  sm:next :bind-form-metadata-service-url ;
  sm:nodeX 784 ;
  sm:nodeY 331 ;
  sm:outputVariable "executionId" ;
  sml:value [
      sp:varName "recordKey" ;
    ] ;
.
:bind-form-metadata-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-form-metadata ;
  sm:outputVariable "formMetadataServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "formType" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:bind-form-type
  a sml:BindBySelect ;
  sm:next :bind-form-metadata-service-url ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?formType
WHERE {
    ?r <http://vfn.cz/ontologies/study-manager/formType> ?formTypeStr .
    BIND (str(?formTypeStr) AS ?formType) .
}""" ;
    ] ;
.
:bind-possible-values-query-template
  a sml:BindWithConstant ;
  sm:next :attach-possible-values-hook ;
  sm:outputVariable "possibleValuesQueryTemplate" ;
  sml:value """prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
CONSTRUCT {
      ?value rdfs:label ?label .
      ?value rdfs:comment ?explanation .
}
WHERE {
          ?value rdfs:label ?label .
          ?value rdfs:comment ?explanation .
          ?value a ?entityType .
}
VALUES (?entityType) {
      (<XXXXX>)
}""" ;
.
:bind-record-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-record-graph ;
  sm:outputVariable "recordServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "recordGraphId" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:bind-root-entity
  a sml:BindBySelect ;
  sm:next :create-root-question ;
  sm:next :retrieve-related-dataset-iris ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?rootEntity
WHERE {
    ?rootEntity a fm:root-entity .
}""" ;
    ] ;
.
:bind-root-question
  a sml:BindBySelect ;
  sm:next :layout-form ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?rootQuestion
WHERE {
    ?rootQuestion a doc:question .
    FILTER NOT EXISTS {
        ?superQuestion doc:has_related_question ?rootQuestion .
        ?superQuestion a doc:question .
    }
}""" ;
    ] ;
.
:bind-sgov-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-related-dataset-iris ;
  sm:next :retrieve-sgov ;
  sm:outputVariable "sgovServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:coalesce ;
          sp:arg1 [
              sp:varName "sgovRepositoryUrl" ;
            ] ;
          sp:arg2 [
              a sp:concat ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "formGenRepositoryUrl" ;
                    ] ;
                ] ;
              sp:arg2 "?default-graph-uri=" ;
              sp:arg3 [
                  a sp:encode_for_uri ;
                  sp:arg1 [
                      a sp:str ;
                      sp:arg1 <http://onto.fel.cvut.cz/ontologies/sgov-data> ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:construct-subquestions
  a sml:ApplyConstruct ;
  kbss-module:has-max-iteration-count "15" ;
  sm:next :question-siblings-ordering ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - add intrinsic tropes
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeLabel .
    ?childQ form:has-question-origin ?trope .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
    ?trope a z-sgov-pojem:typ-vlastnosti .
    ?trope rdfs:subClassOf/owl:someValuesFrom ?parentEntity .
    ?trope skos:prefLabel ?tropePrefLabel .
    OPTIONAL {
        ?trope skos:altLabel ?tropeAltLabel .
    } .
    BIND (fl:capitalize-first-letter(COALESCE(?tropeAltLabel, ?tropePrefLabel)) AS ?tropeLabel) .
    ?parentQ form:has-question-origin ?parentEntity .
    BIND (fl:create-q(str(?trope),?executionId) AS ?childQ) .
    FILTER NOT EXISTS {
        ?parentEntity fm:external true .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - add relators
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?relatorLabel .
    ?childQ form:has-question-origin ?childEntity .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
    ?relator a z-sgov-pojem:typ-vztahu .
    ?relator skos:prefLabel ?relatorPrefLabel .
    ?relator rdfs:subClassOf ?parentRestriction .
    ?relator rdfs:subClassOf ?childRestriction .
    OPTIONAL {
        ?relator skos:altLabel ?relatorAltLabel .
    } .
    BIND (fl:capitalize-first-letter(COALESCE(?relatorAltLabel, ?relatorPrefLabel)) AS ?relatorLabel) .
    ?parentRestriction owl:onProperty z-sgov-pojem:má-vztažený-prvek-1 .
    ?parentRestriction owl:someValuesFrom ?parentEntity .
    ?childRestriction owl:onProperty z-sgov-pojem:má-vztažený-prvek-2 .
    ?childRestriction owl:someValuesFrom ?childEntity .
    ?parentQ form:has-question-origin ?parentEntity .
    BIND (fl:create-q(str(?relator),?executionId) AS ?childQ) .
    FILTER (?parentEntity != ?childEntity) .
    FILTER NOT EXISTS {
        ?relator fm:ignore true .
    } .
    FILTER NOT EXISTS {
        ?parentEntity fm:external true .
    }
}""" ;
    ] ;
  sml:replace true ;
.
:create-root-question
  a sml:ApplyConstruct ;
  sm:next :construct-subquestions ;
  sm:next :question-siblings-ordering ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 0 - create root-subquestion question
CONSTRUCT {
    ?rootQ a doc:question .
    ?rootQ rdfs:label ?rootEntityLabel .
    ?rootQ form:has-question-origin ?rootEntity .
}
WHERE {
    ?rootEntity skos:prefLabel ?rootEntityLabel .
    BIND (fl:create-q(CONCAT(str(?rootEntity)),?executionId) AS ?rootQ) .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - create root question
CONSTRUCT {
    ?formQ a doc:question .
    ?formQ rdfs:label ?formLabel .
    ?formQ form:has-question-origin ?formEntity .
    ?formQ doc:has_related_question ?rootQ .
}
WHERE {
    ?rootEntity skos:prefLabel ?rootEntityLabel .
    BIND (fl:create-q(CONCAT(str(?rootEntity)),?executionId) AS ?rootQ) .
    BIND (fl:create-q(CONCAT(str(?rootEntity), \"-form\"),?executionId) AS ?formQ) .
    BIND (CONCAT(str(?rootEntityLabel), \"-form\") AS ?formLabel) .
    BIND (CONCAT(str(?rootEntity), \"-form\") AS ?formEntity) .
}""" ;
    ] ;
  sml:replace false ;
.
:extract-record-key
  a sml:BindBySelect ;
  sm:next :bind-execution-id ;
  sm:nodeX 826 ;
  sm:nodeY 193 ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?recordKey
WHERE {
     ?r  a    <http://vfn.cz/ontologies/study-manager/patient-record> .
     ?r  <http://vfn.cz/ontologies/study-manager/key> ?recordKey
}""" ;
    ] ;
  rdfs:label "bind-record-key" ;
.
:layout-form
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 0 - create form layout question
CONSTRUCT {
    ?rootQuestion form-lt:has-layout-class \"form\" .
}
WHERE {
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - create section layout classes
CONSTRUCT {
    ?sectionQuestion form-lt:has-layout-class \"section\" .
    ?sectionQuestion form-lt:has-layout-class \"collapsed\" .
}
WHERE {
    ?sectionQuestion doc:has_related_question ?subQuestion .
    FILTER (?rootQuestion != ?sectionQuestion) .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - create wizard step layout for top level sections
CONSTRUCT {
    ?topSectionQuestion form-lt:has-layout-class \"wizard-step\" .
    ?topSectionQuestion form-lt:has-layout-class \"section\" .
}
WHERE {
    ?rootQuestion doc:has_related_question ?topSectionQuestion .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "Layout form" ;
.
:merge
  a sml:Merge ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# root question does not have any subquestions
ASK WHERE {
    ?rootQuestion form-lt:has-layout-class \"form\" .
    FILTER NOT EXISTS {
        ?rootQuestion doc:has_related_question ?subQuestion .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question with more than one answer
ASK WHERE {
    ?q a doc:question .
    ?q doc:has_answer ?a1 .
    ?q doc:has_answer ?a2 .
    FILTER (?a1 != ?a2) 
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question without a label
ASK WHERE {
    ?question a doc:question .
    FILTER NOT EXISTS {
        ?question rdfs:label ?label .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question without specified question origin
ASK WHERE {
    ?question a doc:question .
    FILTER NOT EXISTS {
        ?question form:has-question-origin ?origin .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is an empty section within the form
ASK WHERE {
    ?sectionQ form-lt:has-layout-class \"section\" .
    FILTER NOT EXISTS {
        ?sectionQ doc:has_related_question ?subQ .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is no \"form\" element
ASK WHERE {
    FILTER NOT EXISTS {
        ?s form-lt:has-layout-class \"form\" .
    }
}""" ;
    ] ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question with two answers
ASK WHERE {
    ?q a doc:question .
    ?q doc:has_answer ?a1 .
    ?q doc:has_answer ?a2 .
    FILTER (?a1 != ?a2)
}""" ;
    ] ;
  sm:next :transform_Return ;
.
:question-siblings-ordering
  a sml:ApplyConstruct ;
  sm:next :attach-descriptions ;
  sm:next :attach-possible-values-hook ;
  sm:next :bind-root-question ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - make object identifier first
CONSTRUCT {
    ?qSibling form:has-preceding-question ?q .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:object-identifier-quality .
    ?qParent doc:has_related_question ?q .
    ?qParent doc:has_related_question ?qSibling .
    FILTER (?q != ?qSibling) 
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - make sections after regular questions
CONSTRUCT {
    ?qSection form:has-preceding-question ?qSimpleSibling .
}
WHERE {
    ?qParent doc:has_related_question ?qSection .
    ?qParent doc:has_related_question ?qSimpleSibling .
    ?qSection doc:has_related_question ?qSectionChild .
    FILTER NOT EXISTS {
        ?qSimpleSibling doc:has_related_question ?qSimpleSiblingChild .
    } .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 3 - make relators after other types of questions TODO
CONSTRUCT {
}
WHERE {
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 4 - description should be after identifier (TODO does not work)
CONSTRUCT {
    ?qSiblingDescription form:has-preceding-question ?q .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:object-identifier-quality .
    ?qParent doc:has_related_question ?q .
    ?qParent doc:has_related_question ?qSiblingDescription .
    ?qSiblingDescription form:has-question-origin ?description .
    ?description rdfs:subClassOf dc:description .
    FILTER (?q != ?qSiblingDescription)
}""" ;
    ] ;
  sml:replace false ;
.
:retrieve-form-metadata
  a sml:ApplyConstruct ;
  sm:next :bind-root-entity ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
        ?s ?p ?o .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-record-graph
  a sml:ApplyConstruct ;
  sm:next :bind-form-type ;
  sm:next :extract-record-key ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?recordServiceUrl {
        ?s ?p ?o .
    } .
}""" ;
    ] ;
.
:retrieve-related-dataset-iris
  a sml:ApplyConstruct ;
  sm:next :retrieve-related-datasets ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?rootEntity :related-dataset ?importedGlosar .
    ?rootEntity :related-dataset ?importedModel .
}
WHERE {
    SERVICE ?sgovServiceUrl {
        GRAPH ?glosar {
            ?rootEntity skos:inScheme ?glosar .
        } .
        ?slovnik a-popis-dat-pojem:má-glosář ?glosar .
        ?slovnik a-popis-dat-pojem:má-model ?model .
        ?glosar (owl:imports)* ?importedGlosar .
        ?model (owl:imports)* ?importedModel .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-related-datasets
  a sml:ApplyConstruct ;
  sm:next :create-root-question ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    ?rootEntity :related-dataset ?g .
    SERVICE ?sgovServiceUrl {
        GRAPH ?g {
            ?s ?p ?o .
        } .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-sgov
  a sml:ApplyConstruct ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?sgovServiceUrl {
        ?s ?p ?o .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:transform
  a sm:Function ;
  sm:returnModule :transform_Return ;
  rdfs:comment "Transforms sgov related data located in ?endpointUrl with ?sourceGraphId into SForms form." ;
  rdfs:subClassOf sm:Functions ;
.
:transform_Return
  a sml:ReturnRDF ;
  sml:serialization sml:Turtle ;
.
