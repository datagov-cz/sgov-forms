# baseURI: http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms
# imports: http://onto.fel.cvut.cz/ontologies/form-layout
# imports: http://onto.fel.cvut.cz/ontologies/form-lib
# imports: http://onto.fel.cvut.cz/ontologies/form-metadata
# imports: http://onto.fel.cvut.cz/ontologies/lib/sm-module-adapter
# imports: http://onto.fel.cvut.cz/ontologies/lib/spin-function
# imports: http://onto.fel.cvut.cz/ontologies/s-pipes-lib
# imports: https://slovník.gov.cz/základní/model

@prefix : <http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms/> .
@prefix a-popis-dat: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/> .
@prefix a-popis-dat-pojem: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/pojem/> .
@prefix dc: <http://purl.org/dc/terms/> .
@prefix dce: <http://purl.org/dc/elements/1.1/> .
@prefix doc: <http://onto.fel.cvut.cz/ontologies/documentation/> .
@prefix fl: <http://onto.fel.cvut.cz/ontologies/form-lib/> .
@prefix fm: <http://onto.fel.cvut.cz/ontologies/form-metadata/> .
@prefix form: <http://onto.fel.cvut.cz/ontologies/form/> .
@prefix form-ecc-lib: <http://onto.fel.cvut.cz/ontologies/aviation/eccairs-form-lib/> .
@prefix form-lt: <http://onto.fel.cvut.cz/ontologies/form-layout/> .
@prefix kbss-module: <http://onto.fel.cvut.cz/ontologies/lib/module/> .
@prefix kbss-spif: <http://onto.fel.cvut.cz/ontologies/lib/spin-function/> .
@prefix km-rdf4j: <http://onto.fel.cvut.cz/ontologies/lib/module/rdf4j/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix popis-dat-pojem: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/pojem/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix termit: <http://onto.fel.cvut.cz/ontologies/application/termit/> .
@prefix termit-pojem: <http://onto.fel.cvut.cz/ontologies/application/termit/pojem/> .
@prefix v-sgov-pojem: <https://slovník.gov.cz/veřejný-sektor/pojem/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix z-sgov: <https://slovník.gov.cz/základní/> .
@prefix z-sgov-pojem: <https://slovník.gov.cz/základní/pojem/> .

<http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms>
  a owl:Ontology ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-layout> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-lib> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-metadata> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/lib/sm-module-adapter> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/lib/spin-function> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/s-pipes-lib> ;
  owl:imports z-sgov:model ;
.
:attach-answerable-section-logic
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sm:nodeX 320 ;
  sm:nodeY 2097 ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# add visibility logic of questions related to answerable section
CONSTRUCT {     
      ?qChild form:is-relevant-if ?cond .
      ?cond   a form:condition ;
             form:accepts-answer-value true ;
             form:has-tested-question ?qAnswerable ;
     .
}
WHERE {
    ?qAnswerable form-lt:has-layout-class \"answerable\" .
    ?qAnswerable doc:has_related_question ?qChild .
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?qChild), str(?qAnswerable))))) as ?cond)
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-answerable-section-logic" ;
.
:attach-descriptions
  a sml:ApplyConstruct ;
  sm:next :attach-value-types ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# create descriptions
CONSTRUCT {
    ?q dce:description ?description .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    OPTIONAL {
        ?entity skos:definition ?definition .
    } .
    OPTIONAL {
        ?entity skos:scopeNote ?scopeNote .
    } .
    BIND (COALESCE(?definition, ?scopeNote) AS ?description)
}""" ;
    ] ;
  sml:replace false ;
.
:attach-duplicable-questions
  a sml:ApplyConstruct ;
  sm:next :construct-duplicate-questions ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?q :is-duplicable true .
}
WHERE {
	?q a doc:question .
    ?q :has-processing-entity ?entity .
   ?entity   fm:max-cardinality ?cardinality .
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-duplicable-questions" ;
.
:attach-possible-values-hook
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - possible values for internal queries
CONSTRUCT {
    ?question form:has-possible-values-query ?downloadString .
    ?question form-lt:has-layout-class \"type-ahead\" .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
        ?entity fm:external true .
    } .
    ?question form:has-question-origin ?entity .
    BIND (CONCAT(str(?formGenRepositoryUrl), \"?query=\") AS ?dowloadPrefix) .
    BIND (REPLACE(?possibleValuesQueryTemplate, \"XXXXX\", str(?entity)) AS ?downloadSuffixRaw) .
    BIND (ENCODE_FOR_URI(?downloadSuffixRaw) AS ?downloadSuffix) .
    BIND (CONCAT(?dowloadPrefix, ?downloadSuffix) AS ?downloadString)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - possible values for external queries
CONSTRUCT {
    ?question form:has-possible-values-query ?downloadString .
    ?question form-lt:has-layout-class \"type-ahead\" .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
		 ?codelistMapping a fm:codelist-mapping ;
              fm:has-codelist-service-url ?codeListServiceUrl  ;
              fm:has-codelist-entity ?codeListEntity ; 
              fm:has-internal-entity ?entity  ;
          .
    } .

    ?question form:has-question-origin ?entity .
    BIND (CONCAT(str(?formGenRepositoryUrl), \"?query=\") AS ?dowloadPrefix) .
    BIND (REPLACE(?externalPossibleValuesQueryTemplate, \"XXX_SERVICE_XXX\", str(?codeListServiceUrl)) AS ?preparedPossibleValuesQueryTemplate) .
    BIND (REPLACE(?preparedPossibleValuesQueryTemplate, \"XXXXX\", str(?codeListEntity)) AS ?downloadSuffixRaw) .
    BIND (ENCODE_FOR_URI(?downloadSuffixRaw) AS ?downloadSuffix) .
    BIND (CONCAT(?dowloadPrefix, ?downloadSuffix) AS ?downloadString)
}""" ;
    ] ;
  sml:replace true ;
.
:attach-root-question
  a sml:ApplyConstruct ;
  sm:next :construct-question-origins ;
  sm:next :construct-subquestions ;
  sm:next :merge-with-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 0 - create root-subquestion question
CONSTRUCT {
    ?rootQ a doc:question .
    ?rootQ rdfs:label ?rootEntityLabel .
    ?rootQ :has-processing-entity ?rootEntity .
}
WHERE {
    ?rootEntity skos:prefLabel ?rootEntityLabel .
    BIND (fl:create-q(CONCAT(str(?rootEntity)),?executionId) AS ?rootQ) .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - create root question
CONSTRUCT {
    ?formQ a doc:question .
    ?formQ rdfs:label ?formLabel .
    ?formQ form:has-question-origin ?formEntity .
    ?formQ doc:has_related_question ?rootQ .
}
WHERE {
    ?rootEntity skos:prefLabel ?rootEntityLabel .
    BIND (fl:create-q(CONCAT(str(?rootEntity)),?executionId) AS ?rootQ) .
    BIND (fl:create-q(CONCAT(str(?rootEntity), \"-form\"),?executionId) AS ?formQ) .
    BIND (CONCAT(str(?rootEntityLabel), \"-form\") AS ?formLabel) .
    BIND (IRI(CONCAT(str(?rootEntity), \"-form\")) AS ?formEntity) .
}""" ;
    ] ;
  sml:replace false ;
.
:attach-transitive-vocabulary-dependencies
  a sml:ApplyConstruct ;
  sm:next :construct-related-dataset-iris ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
   ?dependantVocab popis-dat-pojem:používá-pojmy-ze-slovníku ?usedVocab .
}
WHERE {
   ?dependantVocab popis-dat-pojem:používá-přímo-pojmy-ze-slovníku+ ?usedVocab .
}""" ;
    ] ;
.
:attach-value-types
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# boolean
CONSTRUCT {
    ?q form-lt:has-layout-class \"checkbox\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:boolean .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# date
CONSTRUCT {
    ?q form-lt:has-layout-class \"masked-input\" .
    ?q form:has-input-mask \"DD/MM/YYYY\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:date .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# datetime
CONSTRUCT {
    ?q form-lt:has-layout-class \"datetime\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:datetime .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# number
CONSTRUCT {
    ?q form-lt:has-layout-class \"number\" .
    ?q form:has-datatype xsd:int .
    ?q xsd:minInclusive ?minInclusive  .
    ?q xsd:maxInclusive ?maxInclusive .
    ?q form:step ?step .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:number .
    OPTIONAL {
          ?entity xsd:minInclusive ?minInclusiveOptional .
    }
    OPTIONAL {
          ?entity xsd:maxInclusive ?maxInclusiveOptional .
    }
    OPTIONAL {
          ?entity fm:step ?stepOptional .
    }
    BIND(coalesce(?minInclusiveOptional, 0) as ?minInclusive)
    BIND(coalesce(?maxInclusiveOptional, 10000) as ?maxInclusive)
    BIND(coalesce(?stepOptional, 1) as ?step)

}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# textarea
CONSTRUCT {
    ?q form-lt:has-layout-class \"textarea\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:textarea .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# time
CONSTRUCT {
    ?q form-lt:has-layout-class \"time\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:time .
}""" ;
    ] ;
  sml:replace false ;
.
:bind-default-language
  a sml:BindWithConstant ;
  sm:next :construct-dny-v-tydnu-questions ;
  sm:outputVariable "defaultLanguage" ;
  sml:value "cs" ;
  rdfs:label "bind-default-language" ;
.
:bind-execution-id
  a sml:BindBySelect ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# multiple root questions exists
ASK
WHERE {
           ?qRoot1 a doc:question .
           FILTER NOT EXISTS {
                 ?qNE1 a doc:question .
                 ?qNE1 doc:has_related_question ?qRoot1 .
           }
           ?qRoot2 a doc:question .
           FILTER NOT EXISTS {
                 ?qNE2 a doc:question .
                 ?qNE2 doc:has_related_question ?qRoot2 .
           }
           FILTER(?qRoot1 != ?qRoot2)
}""" ;
      sp:where (
          [
            sp:object doc:question ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "qRoot1" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object doc:question ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "qNE1" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "qRoot1" ;
                        ] ;
                      sp:predicate doc:has_related_question ;
                      sp:subject [
                          sp:varName "qNE1" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            sp:object doc:question ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "qRoot2" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object doc:question ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "qNE2" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "qRoot2" ;
                        ] ;
                      sp:predicate doc:has_related_question ;
                      sp:subject [
                          sp:varName "qNE2" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:ne ;
                sp:arg1 [
                    sp:varName "qRoot1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "qRoot2" ;
                  ] ;
              ] ;
          ]
        ) ;
      rdfs:comment "multiple root questions exists" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# root quesiton is bound but does not have recognizable IRI
ASK WHERE {
      ?qRoot a doc:question .
      FILTER NOT EXISTS {
            ?qNE a doc:question .
            ?qNE doc:has_related_question ?qRoot .
       }
      FILTER (!regex(str(?qRoot), \"^.*-form-.*-q$\")) .
}""" ;
    ] ;
  sm:next :bind-form-metadata-service-url ;
  sml:selectQuery [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "executionId" ;
          ]
        ) ;
      sp:text """# bind executionId based on root question or generate new
SELECT ?executionId
WHERE {
     OPTIONAL {
           ?qRoot a doc:question .
           FILTER NOT EXISTS {
                 ?qNE a doc:question .
                 ?qNE doc:has_related_question ?qRoot
           }
           BIND(replace(replace(str(?qRoot), \"^.*form-\", \"\"),\"-q$\",\"\") as ?inferredExecutionId) 
     }
     BIND(COALESCE(?inferredExecutionId, STRUUID()) as ?executionId)
}""" ;
      sp:where (
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object doc:question ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "qRoot" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:notExists ;
                      sp:elements (
                          [
                            sp:object doc:question ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "qNE" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "qRoot" ;
                              ] ;
                            sp:predicate doc:has_related_question ;
                            sp:subject [
                                sp:varName "qNE" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:replace ;
                      sp:arg1 [
                          a sp:replace ;
                          sp:arg1 [
                              a sp:str ;
                              sp:arg1 [
                                  sp:varName "qRoot" ;
                                ] ;
                            ] ;
                          sp:arg2 "^.*form-" ;
                          sp:arg3 "" ;
                        ] ;
                      sp:arg2 "-q$" ;
                      sp:arg3 "" ;
                    ] ;
                  sp:variable [
                      sp:varName "inferredExecutionId" ;
                    ] ;
                ]
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "inferredExecutionId" ;
                  ] ;
                sp:arg2 [
                    a sp:struuid ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "executionId" ;
              ] ;
          ]
        ) ;
      rdfs:comment "bind executionId based on root question or generate new" ;
    ] ;
  rdfs:label "bind-execution-id" ;
.
:bind-external-possible-values-query-template
  a sml:BindWithConstant ;
  sm:next :attach-possible-values-hook ;
  sm:nodeX 1750 ;
  sm:nodeY 1575 ;
  sm:outputVariable "externalPossibleValuesQueryTemplate" ;
  sml:value """prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix dce: <http://purl.org/dc/elements/1.1/>
prefix form: <http://onto.fel.cvut.cz/ontologies/form/> 

CONSTRUCT {
      # TODO remove
      <https://data.mvcr.gov.cz/zdroj/číselníky/sporty/položky/aerobik> form:has-preceding-value <http://publications.europa.eu/resource/authority/currency/CZK> . 
      <https://data.mvcr.gov.cz/zdroj/číselníky/sporty/položky/aerobik> form:has-preceding-value <http://publications.europa.eu/resource/authority/currency/EUR> .
      <https://data.mvcr.gov.cz/zdroj/číselníky/sporty/položky/aerobik> form:has-preceding-value <http://publications.europa.eu/resource/authority/currency/USD> .
      ?value rdfs:label ?labelStr .
      ?value rdfs:comment ?explanationStr .
}
WHERE {
  SERVICE   <XXX_SERVICE_XXX>  {
     SELECT ?value ?labelStr ?explanationStr ?entityType { 
          ?value skos:inScheme ?entityType .

          ?value skos:prefLabel ?label .
          FILTER ( lang(?label) = \"cs\" ) 
          BIND(str(?label) as ?labelStr)

          OPTIONAL {
              ?value dce:description ?explanation .
              FILTER ( lang(?explanation) = \"cs\" ) 
              BIND(str(?explanation) as ?explanationStr)
          }

      } VALUES (?entityType) {
        (<XXXXX>)
      }
  }
}""" ;
  rdfs:label "bind-external-possible-values-query-template" ;
.
:bind-form-metadata-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-form-metadata ;
  sm:outputVariable "formMetadataServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "formTemplate" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:bind-form-template
  a sml:BindBySelect ;
  sm:next :bind-form-metadata-service-url ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?formTemplate
WHERE {
    ?r <http://vfn.cz/ontologies/study-manager/has-form-template> ?formTemplateStr .
    BIND (str(?formTemplateStr) AS ?formTemplate) .
}""" ;
    ] ;
.
:bind-possible-values-query-template
  a sml:BindWithConstant ;
  sm:next :attach-possible-values-hook ;
  sm:outputVariable "possibleValuesQueryTemplate" ;
  sml:value """prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
CONSTRUCT {
      ?value rdfs:label ?label .
      ?value rdfs:comment ?explanation .
}
WHERE {
          ?value rdfs:label ?label .
          ?value rdfs:comment ?explanation .
          ?value a ?entityType .
}
VALUES (?entityType) {
      (<XXXXX>)
}""" ;
.
:bind-record-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-record-graph ;
  sm:outputVariable "recordServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "recordGraphId" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:bind-root-entity
  a sml:BindBySelect ;
  sm:next :attach-root-question ;
  sm:next :construct-related-dataset-iris ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?rootEntity
WHERE {
    ?rootEntity a fm:root-entity .
}""" ;
    ] ;
.
:bind-root-question
  a sml:BindBySelect ;
  sm:next :layout-form ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?rootQuestion
WHERE {
    ?rootQuestion a doc:question .
    FILTER NOT EXISTS {
        ?superQuestion doc:has_related_question ?rootQuestion .
        ?superQuestion a doc:question .
    }
}""" ;
    ] ;
.
:bind-sgov-service-url
  a sml:BindWithConstant ;
  sm:next :construct-direct-vocabulary-dependencies ;
  sm:next :retrieve-sgov ;
  sm:outputVariable "sgovServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:coalesce ;
          sp:arg1 [
              sp:varName "sgovRepositoryUrl" ;
            ] ;
          sp:arg2 [
              a sp:concat ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "formGenRepositoryUrl" ;
                    ] ;
                ] ;
              sp:arg2 "?default-graph-uri=" ;
              sp:arg3 [
                  a sp:encode_for_uri ;
                  sp:arg1 [
                      a sp:str ;
                      sp:arg1 <http://onto.fel.cvut.cz/ontologies/sgov-data> ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:construct-direct-vocabulary-dependencies
  a sml:ApplyConstruct ;
  sm:next :attach-transitive-vocabulary-dependencies ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
     ?dependantVocab popis-dat-pojem:používá-přímo-pojmy-ze-slovníku ?usedVocab .
} WHERE {
   SERVICE ?sgovServiceUrl {
      GRAPH ?dependantVocab {
           ?dependantVocab	a popis-dat-pojem:slovník	.
           ?s ?p ?usedConcept .
       }    
       GRAPH ?usedVocab {    	
          ?usedVocab a popis-dat-pojem:slovník	.
          ?usedConcept skos:inScheme ?importedGlosary .
        }
        FILTER(?dependantVocab != ?usedVocab)
   }
}""" ;
    ] ;
.
:construct-dny-v-tydnu-questions
  a sml:ApplyConstruct ;
  sm:next :attach-duplicable-questions ;
  sm:next :question-siblings-ordering ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# TODO remove layout class 
CONSTRUCT {  
      ?childQ a doc:question .
      ?childQ rdfs:label ?valueLabel .
      ?childQ form:has-question-origin ?value .
      ?childQ form-lt:has-layout-class \"checkbox\" .
      ?parentQ doc:has_related_question ?childQ .
}
WHERE {
   #TODO remove constants
   BIND(<https://slovník.gov.cz/generický/číselníky/pojem/den-v-týdnu> as ?parentEntity)

    ?parentQ form:has-question-origin ?parentEntity .

    ?codelistMapping a fm:codelist-mapping ;
        fm:has-codelist-service-url ?codeListServiceUrl  ;
        fm:has-codelist-entity ?codeListEntity ; 
        fm:has-internal-entity ?parentEntity  ;
     .

    SERVICE ?codeListServiceUrl {
            ?value skos:inScheme ?codeListEntity .
            ?value skos:prefLabel ?valueLabel .
    }
   BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
   BIND (fl:create-q(str(?value),?childExecutionId) AS ?childQ) .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-dny-v-tydnu-questions" ;
.
:construct-duplicate-questions
  a sml:ApplyConstruct ;
  kbss-module:has-max-iteration-count "1" ;
  sm:next :question-siblings-ordering ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - construct deep copy of questions
# TODO - not systematic
CONSTRUCT {
     ?qRootParent doc:has_related_question ?qRootX .
     ?qDescendantX doc:has_related_question ?qDescendantChildX .
     ?qDescendantX ?p ?o .
}
WHERE {

     VALUES ?card { 1 2 3 4 }

     ?qRoot :is-duplicable true .
     ?qRoot doc:has_related_question* ?qDescendant .

# attach to root
     ?qRootParent doc:has_related_question ?qRoot .

# construct doc:has_related_question taxonomy
     OPTIONAL {
         ?qDescendant doc:has_related_question ?qDescendantChild .
     }

# attach specific properties
     OPTIONAL {
          ?qDescendant ?p ?o .
          FILTER(?p != doc:has_related_question )
     }

     BIND(fl:create-q(?qRoot, ?card) as ?qRootX)
     BIND(fl:create-q(?qDescendant, ?card) as ?qDescendantX)
     BIND(fl:create-q(?qDescendantChild, ?card) as ?qDescendantChildX)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 -  construct hiding logic and ordering
# todo make is-relevant-if automatic from an attribute
CONSTRUCT {
      ?qRoot form-lt:has-layout-class \"answerable\" .
      ?qRoot form-lt:has-layout-class \"checkbox\" .

      ?qRootX form-lt:has-layout-class \"answerable\" .
      ?qRootX form-lt:has-layout-class \"checkbox\" .

    ?qRootX form:has-preceding-question  ?qRootP .

     ?qRootX form:is-relevant-if  ?condP .
     ?condP   a form:condition ;
             form:accepts-answer-value true ;
             form:has-tested-question ?qRootP ;
    .
}
WHERE {
    VALUES ?card { 1 2 3 4 }

    ?qRoot :is-duplicable true .

    BIND(fl:create-q(?qRoot, ?card) as ?qRootX)
    BIND( IF(?card=1, ?qRoot, fl:create-q(?qRoot, ?card-1)) as ?qRootP)

    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?qRootX), str(?qRootP))))) as ?condP)
}""" ;
    ] ;
  rdfs:label "construct-duplicate-questions" ;
.
:construct-metaquestions
  a sml:ApplyConstruct ;
  sm:next :attach-answerable-section-logic ;
  sm:nodeX 99 ;
  sm:nodeY 1926 ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct show advanced quesitons and ordering
# TODO - remove form-layout
CONSTRUCT {
     ?parentQ doc:has_related_question ?showAdvancedQ .
     ?showAdvancedQ a doc:question ;
          rdfs:label \"Zobrazit více\" ;
          dce:description \"Zobrazí/Skryje pokročilé otázky. Otázky,  které jsou zodpovězeny a sekce, které obsahují zodpovězené otázky nelze skrýt.\" ;
          form-lt:has-layout-class \"checkbox\" ;
          form:show-advanced-question true ;
      .
      ?q form:is-relevant-if ?orCondition .
      ?orCondition a form:or-condition ;
             form:has-sub-condition ?condShowAdvanced ;
             form:has-sub-condition ?condHasAnswer ;
      .
      ?condShowAdvanced   a form:condition ;
             form:has-tested-question ?showAdvancedQ ;
             form:accepts-answer-value true ;
      .
      ?condHasAnswer   a form:condition ;
             form:has-tested-question ?q ;
             form:accepts form:answered-question ;
      .

# TODO  do specific metadata questions ordering
      ?q form:has-preceding-question ?showAdvancedQ . 
}
WHERE {
    ?parentQ doc:has_related_question ?advancedQ .
    ?advancedQ fm:is-advanced true .
    ?parentQ doc:has_related_question ?q  .
    ?q fm:is-advanced true .
    
 
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(form:show-advanced-question),?childExecutionId) AS ?showAdvancedQ) 
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?parentQ), str(?showAdvancedQ))))) as ?condShowAdvanced)
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?showAdvancedQ), str(?q))))) as ?condHasAnswer)
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?showAdvancedQ), str(?q), str(?parentQ))))) as ?orCondition)
 
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-metaquestions" ;
.
:construct-question-origins
  a sml:ApplyConstruct ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# question has multipe origins
ASK
WHERE {
     ?q  form:has-question-origin ?qO1 .
     ?q  form:has-question-origin ?qO2 .
     FILTER(?qO1 != ?qO2)
}""" ;
    ] ;
  sm:next :merge-with-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct from processed entities
CONSTRUCT {
   ?q form:has-question-origin ?qO .
}
WHERE {
    ?q :has-processed-entity ?qO .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct from processing entities
CONSTRUCT {
   ?q form:has-question-origin ?qO .
}
WHERE {
    ?q :has-processing-entity ?qO .
    FILTER NOT EXISTS {
              ?q :has-processing-entity ?qONotExists .
              ?qO rdfs:subClassOf+ ?qONotExists .
    }
}""" ;
    ] ;
  sml:replace true ;
.
:construct-related-dataset-iris
  a sml:ApplyConstruct ;
  sm:next :retrieve-related-datasets ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?rootEntity :related-dataset ?usedVocab .
    ?rootEntity :related-dataset ?vocabulary .
}
WHERE {
     SERVICE ?sgovServiceUrl {
        ?rootEntity skos:inScheme ?glosary .
        ?vocabulary a-popis-dat-pojem:má-glosář ?glosary .
        ?vocabulary a-popis-dat-pojem:má-model ?model .
     }  
     
     ?vocabulary popis-dat-pojem:používá-pojmy-ze-slovníku ?usedVocab .      
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-related-dataset-iris" ;
.
:construct-subquestions
  a sml:ApplyConstruct ;
  kbss-module:has-max-iteration-count "4" ;
  sm:next :construct-question-origins ;
  sm:next :merge-with-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - add intrinsic tropes
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeLabel .
    ?childQ :has-processing-entity ?trope .
    ?childQ :has-related-entity ?parentEntity .
    ?childQ  fm:is-advanced ?isAdvanced .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
    ?trope a z-sgov-pojem:typ-vlastnosti .
    ?trope rdfs:subClassOf/owl:someValuesFrom ?parentEntity .
    ?trope skos:prefLabel ?tropePrefLabel .
    OPTIONAL {
        ?trope skos:altLabel ?tropeAltLabel .
    } .
    BIND (fl:capitalize-first-letter(COALESCE(?tropeAltLabel, ?tropePrefLabel)) AS ?tropeLabel) .
    ?parentQ :has-processing-entity ?directParentEntity .
    ?directParentEntity rdfs:subClassOf* ?parentEntity .
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(?trope),?childExecutionId) AS ?childQ) .
    OPTIONAL {
        ?trope fm:is-advanced true .
         BIND(true as ?isAdvanced)
    }
    FILTER NOT EXISTS {
        ?trope fm:ignore true .
    } . 
    FILTER NOT EXISTS {
        ?parentEntity fm:ignore true .
    } . 
    FILTER NOT EXISTS {
        ?parentEntity fm:external true .
    }
    FILTER NOT EXISTS {
        ?ic a fm:ignore-condition ;
              fm:has-parent-entity ?directParentEntity  ;
              fm:has-ignored-entity ?trope  ;
        .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - add relators
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?relatorLabel .
    ?childQ :has-processing-entity ?childEntity .
    ?childQ :has-related-entity ?parentEntity .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
    ?relator a z-sgov-pojem:typ-vztahu .
    ?relator skos:prefLabel ?relatorPrefLabel .
    ?relator rdfs:subClassOf ?parentRestriction .
    ?relator rdfs:subClassOf ?childRestriction .
    OPTIONAL {
        ?relator skos:altLabel ?relatorAltLabel .
    } .
    BIND (fl:capitalize-first-letter(COALESCE(?relatorAltLabel, ?relatorPrefLabel)) AS ?relatorLabel) .
    ?parentRestriction owl:onProperty z-sgov-pojem:má-vztažený-prvek-1 .
    ?parentRestriction owl:someValuesFrom ?parentEntity .
    ?childRestriction owl:onProperty z-sgov-pojem:má-vztažený-prvek-2 .
    ?childRestriction owl:someValuesFrom ?childEntity .
    ?parentQ :has-processing-entity ?directParentEntity .
    ?directParentEntity rdfs:subClassOf* ?parentEntity .
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(?relator),?childExecutionId) AS ?childQ) .
    FILTER (?parentEntity != ?childEntity) .
    FILTER NOT EXISTS {
        ?relator fm:ignore true .
    } 
    FILTER NOT EXISTS {
        ?parentEntity fm:ignore true .
    }
    FILTER NOT EXISTS {
        ?parentEntity fm:external true .
    }
    FILTER NOT EXISTS {
        ?ic a fm:ignore-condition ;
              fm:has-parent-entity ?directParentEntity  ;
              fm:has-ignored-entity ?childEntity  ;
        .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 3 - add questions for most specific subclasses
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?mostSpecificEntityLabel .
    ?childQ :has-processed-entity ?mostSpecificEntity .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
     ?parentQ :has-processing-entity ?parentEntity .
     ?mostSpecificEntity rdfs:subClassOf+ ?parentEntity   .
     ?mostSpecificEntity skos:prefLabel ?mostSpecificEntityLabel .
     FILTER NOT EXISTS {
          ?notExistMoreSpecificEntity rdfs:subClassOf ?mostSpecificEntity .
     }
     BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
     BIND (fl:create-q(str(?mostSpecificEntity),?childExecutionId) AS ?childQ) .
     FILTER NOT EXISTS {
          ?mostSpecificEntity fm:ignore true .
      } 
      FILTER NOT EXISTS {
          ?parentEntity fm:ignore true .
       }
      FILTER NOT EXISTS {
          ?parentEntity fm:external true .
      }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 4 - propagate processed entities to parent question
CONSTRUCT {
     ?parentQ :has-processing-entity ?qO  .     
}
WHERE {
    ?parentQ doc:has_related_question ?childQ .
    ?childQ :has-processed-entity ?qO .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 5 - add question for value of complex trope
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeValueLabel .
    ?childQ :has-processing-entity ?tropeValue .
# TODO related-entity cannot be applied
#  ?childQ :has-related-entity ?trope .
     ?parentQ doc:has_related_question ?childQ .
} WHERE {
     ?trope a z-sgov-pojem:typ-vlastnosti .
     ?parentQ :has-processing-entity ?trope .
     ?parentQ doc:has_related_question ?filteringQ . 
     ?filteringQ :has-processed-entity ?qO . 
     FILTER NOT EXISTS {
              ?parentQ :has-processing-entity ?tropeNotExists .
              ?trope rdfs:subClassOf+ ?tropeNotExists .
      }

     BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
     BIND(IRI(concat(str(?trope),\"-value\")) as ?tropeValue)
     BIND (fl:create-q(str(?tropeValue),?childExecutionId) AS ?childQ) .
     BIND(\"Hodnota\" as ?tropeValueLabel)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 7 - add multilingual labels
# TODO refactor
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeLabel .
    ?childQ :has-processing-entity ?trope .
    ?childQ :has-related-entity ?parentEntity .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
	?parentQ  :has-processing-entity ?parentEntity  .
    ?parentEntity a fm:multilingual-quality .
    ?trope a fm:language .
    ?trope  skos:prefLabel ?tropeLabel .
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(?trope),?childExecutionId) AS ?childQ) .
    FILTER NOT EXISTS {
        ?trope fm:ignore true .
    } .
}""" ;
    ] ;
  sml:replace true ;
.
:construct-type-filters
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 -  type filter questions are boolean
CONSTRUCT {
         ?q form-lt:has-layout-class \"checkbox\" .
}
WHERE {
        ?q :has-processed-entity ?qO.
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2- filtering of tropes and relators based on type
CONSTRUCT {
     ?filteredQ form:is-relevant-if [
           a form:condition ;
           form:accepts-answer-value true ;
           form:has-tested-question ?testedQ ;
      ] .     
}
WHERE {
    ?q doc:has_related_question ?testedQ  . 
    ?testedQ :has-processed-entity ?testedEntity .

    ?q doc:has_related_question ?filteredQ . 
    ?filteredQ :has-processing-entity ?aspect .
    ?filteredQ :has-related-entity ?filteredEntity .  
    ?testedEntity rdfs:subClassOf*  ?filteredEntity
}""" ;
    ] ;
  sml:replace false ;
.
:has-algorithm-related-property
  a rdf:Property ;
.
:has-processed-entity
  a rdf:Property ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:has-processing-entity
  a owl:ObjectProperty ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:has-related-entity
  a owl:ObjectProperty ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:ignore-cycles
  a sml:ApplyConstruct ;
  sm:next :construct-subquestions ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# Ignore entities that would cause cycles
CONSTRUCT {
     ?entity fm:ignore true .
}
WHERE {
    
} VALUES (?entity) {
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-konec>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-začátek>) 
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-lokalizaci>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-kontext>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/opakovaná-časová-specifikace>)
    (<https://slovník.gov.cz/generický/částky/pojem/jednotková-částka>)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# v modelu Částky dvě entity ukazují na stejnou vlastnost se stejnou kardinalitou
CONSTRUCT {
     ?entity fm:ignore true .
}
WHERE {
    
} VALUES (?entity) {
    (<https://slovník.gov.cz/generický/částky/pojem/jednotková-částka>)
}""" ;
    ] ;
.
:layout-form
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 0 - create form layout question
CONSTRUCT {
    ?rootQuestion form-lt:has-layout-class \"form\" .
}
WHERE {
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - create section layout classes
CONSTRUCT {
    ?sectionQuestion form-lt:has-layout-class \"section\" .
    ?sectionQuestion form-lt:has-layout-class \"collapsed\" .
}
WHERE {
    ?sectionQuestion doc:has_related_question ?subQuestion .
    FILTER (?rootQuestion != ?sectionQuestion) .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - create wizard step layout for top level sections
CONSTRUCT {
    ?topSectionQuestion form-lt:has-layout-class \"wizard-step\" .
    ?topSectionQuestion form-lt:has-layout-class \"section\" .
}
WHERE {
    ?rootQuestion doc:has_related_question ?topSectionQuestion .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "Layout form" ;
.
:merge
  a sml:Merge ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# root question does not have any subquestions
ASK WHERE {
    ?rootQuestion form-lt:has-layout-class \"form\" .
    FILTER NOT EXISTS {
        ?rootQuestion doc:has_related_question ?subQuestion .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question with more than one answer
ASK WHERE {
    ?q a doc:question .
    ?q doc:has_answer ?a1 .
    ?q doc:has_answer ?a2 .
    FILTER (?a1 != ?a2)
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question with two parent question
ASK
WHERE {
    ?parentQ1 doc:has_related_question ?q .
    ?parentQ2 doc:has_related_question ?q .
    FILTER(?parentQ1 != ?parentQ2)
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question without a label
ASK WHERE {
    ?question a doc:question .
    FILTER NOT EXISTS {
        ?question rdfs:label ?label .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question without specified question origin
ASK WHERE {
    ?question a doc:question .
    FILTER NOT EXISTS {
        ?question form:has-question-origin ?origin .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is an empty section within the form
ASK WHERE {
    ?sectionQ form-lt:has-layout-class \"section\" .
    FILTER NOT EXISTS {
        ?sectionQ doc:has_related_question ?subQ .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is asserted ordering between questions that does not have same parent
ASK WHERE {
    ?q2 form:has-preceding-question ?q1 .
    FILTER NOT EXISTS {
        ?qParent doc:has_related_question ?q1 .
        ?qParent doc:has_related_question ?q2 .
    } .
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is cycle in has-preceding-quesiton relation
ASK WHERE {
    ?q1 form:has-preceding-question ?q2 .
    ?q2 (form:has-preceding-question)* ?q1 .
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is no \"form\" element
ASK WHERE {
    FILTER NOT EXISTS {
        ?s form-lt:has-layout-class \"form\" .
    }
}""" ;
    ] ;
  sm:next :transform_Return ;
.
:merge-with-origins
  a sml:Merge ;
  sm:next :attach-duplicable-questions ;
  sm:next :construct-dny-v-tydnu-questions ;
  sm:next :question-siblings-ordering ;
  rdfs:label "merge-with-origins" ;
.
:question-siblings-ordering
  a sml:ApplyConstruct ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# 0 - has preceding relation is cyclic
ASK
WHERE {
     ?q doc:has_related_question ?child1Q .
     ?q doc:has_related_question ?child2Q .

     ?child1Q form:has-preceding-question ?child2Q .
     ?child2Q form:has-preceding-question* ?child1Q .
     FILTER(?child1Q != ?child2Q)
}""" ;
    ] ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# 1 - has preceding question relation is reflexive
ASK
WHERE {
     ?q form:has-preceding-question ?q .
}""" ;
    ] ;
  sm:next :attach-answerable-section-logic ;
  sm:next :attach-descriptions ;
  sm:next :attach-possible-values-hook ;
  sm:next :bind-root-question ;
  sm:next :construct-metaquestions ;
  sm:next :construct-type-filters ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - make object identifier first
CONSTRUCT {
    ?qSibling form:has-preceding-question ?q .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:object-identifier-quality .
    ?qParent doc:has_related_question ?q .
    ?qParent doc:has_related_question ?qSibling .
    ?qSibling form:has-question-origin ?siblingEntity .
    FILTER (?q != ?qSibling) 
    FILTER NOT EXISTS {
        ?siblingEntity a fm:object-identifier-quality .
    }
    FILTER NOT EXISTS {
            ?qSibling  :has-processed-entity ?qo.
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - make sections after regular questions
CONSTRUCT {
    ?qSection form:has-preceding-question ?qSimpleSibling .
}
WHERE {
    ?qParent doc:has_related_question ?qSection .
    ?qParent doc:has_related_question ?qSimpleSibling .
    ?qSection doc:has_related_question ?qSectionChild .
     FILTER NOT EXISTS {
        ?qSection form:has-question-origin ?sectionEntity .
        ?sectionEntity a fm:object-identifier-quality .
    }
    FILTER NOT EXISTS {
        ?qSimpleSibling doc:has_related_question ?qSimpleSiblingChild .
    } .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 3 - make relators after other types of questions TODO
CONSTRUCT {
}
WHERE {
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 4 - description should be after identifier (TODO does not work)
CONSTRUCT {
    ?qSiblingDescription form:has-preceding-question ?q .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a fm:object-identifier-quality .
    ?qParent doc:has_related_question ?q .
    ?qParent doc:has_related_question ?qSiblingDescription .
    ?qSiblingDescription form:has-question-origin ?description .
    ?description rdfs:subClassOf dc:description .
    FILTER (?q != ?qSiblingDescription)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 5 - order section filtering question before others
CONSTRUCT {
    ?qNotFilteringQ form:has-preceding-question ?qFilteringQ .
}
WHERE {
    ?q doc:has_related_question ?qFilteringQ  . 
    ?q doc:has_related_question ?qNotFilteringQ . 
    ?qFilteringQ :has-processed-entity ?qo1 .
    ?qNotFilteringQ :has-processing-entity ?qo2 .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 6 - order if entities by time
# TODO need to model it
CONSTRUCT {
      ?laterQ form:has-preceding-question ?earlierQ     .
}
WHERE {
       ?q doc:has_related_question ?earlierQ  . 
       ?earlierQ form:has-question-origin ?earlierQO . 
       ?q doc:has_related_question ?laterQ . 
       ?laterQ form:has-question-origin ?laterQO . 
       ?earlierQO fm:precedes-relatively-in-time ?laterQO     .
}""" ;
    ] ;
  sml:replace false ;
.
:retrieve-form-metadata
  a sml:ApplyConstruct ;
  sm:next :bind-root-entity ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
        ?s ?p ?o .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-record-graph
  a sml:ApplyConstruct ;
  sm:next :bind-execution-id ;
  sm:next :bind-form-template ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?recordServiceUrl {
        ?s ?p ?o .
    } .
}""" ;
    ] ;
.
:retrieve-related-datasets
  a sml:ApplyConstruct ;
  sm:next :attach-root-question ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    ?rootEntity :related-dataset ?g .
    SERVICE ?sgovServiceUrl {
        GRAPH ?g {
            ?s ?p ?o .
        } .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-sgov
  a sml:ApplyConstruct ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?sgovServiceUrl {
        ?s ?p ?o .
    } 
}""" ;
    ] ;
  sml:replace true ;
.
:transform
  a sm:Function ;
  sm:returnModule :transform_Return ;
  rdfs:comment "Transforms sgov related data located in ?endpointUrl with ?sourceGraphId into SForms form." ;
  rdfs:subClassOf sm:Functions ;
.
:transform_Return
  a sml:ReturnRDF ;
  sml:serialization sml:Turtle ;
.
