# baseURI: http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms
# imports: http://onto.fel.cvut.cz/ontologies/form-layout
# imports: http://onto.fel.cvut.cz/ontologies/form-lib
# imports: http://onto.fel.cvut.cz/ontologies/form-template
# imports: http://onto.fel.cvut.cz/ontologies/lib/sm-module-adapter
# imports: http://onto.fel.cvut.cz/ontologies/lib/spin-function
# imports: http://onto.fel.cvut.cz/ontologies/s-pipes-lib
# imports: https://slovník.gov.cz/základní/model

@prefix : <http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms/> .
@prefix a-popis-dat: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/> .
@prefix a-popis-dat-pojem: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/pojem/> .
@prefix dc: <http://purl.org/dc/terms/> .
@prefix dce: <http://purl.org/dc/elements/1.1/> .
@prefix doc: <http://onto.fel.cvut.cz/ontologies/documentation/> .
@prefix fl: <http://onto.fel.cvut.cz/ontologies/form-lib/> .
@prefix form: <http://onto.fel.cvut.cz/ontologies/form/> .
@prefix form-ecc-lib: <http://onto.fel.cvut.cz/ontologies/aviation/eccairs-form-lib/> .
@prefix form-lt: <http://onto.fel.cvut.cz/ontologies/form-layout/> .
@prefix ft: <http://onto.fel.cvut.cz/ontologies/form-template/> .
@prefix kbss-module: <http://onto.fel.cvut.cz/ontologies/lib/module/> .
@prefix kbss-spif: <http://onto.fel.cvut.cz/ontologies/lib/spin-function/> .
@prefix km-rdf4j: <http://onto.fel.cvut.cz/ontologies/lib/module/rdf4j/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix popis-dat-pojem: <http://onto.fel.cvut.cz/ontologies/slovník/agendový/popis-dat/pojem/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix termit: <http://onto.fel.cvut.cz/ontologies/application/termit/> .
@prefix termit-pojem: <http://onto.fel.cvut.cz/ontologies/application/termit/pojem/> .
@prefix v-sgov-pojem: <https://slovník.gov.cz/veřejný-sektor/pojem/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix z-sgov: <https://slovník.gov.cz/základní/> .
@prefix z-sgov-pojem: <https://slovník.gov.cz/základní/pojem/> .

<http://onto.fel.cvut.cz/ontologies/kodi/sgov2sforms>
  a owl:Ontology ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-layout> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-lib> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/form-template> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/lib/sm-module-adapter> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/lib/spin-function> ;
  owl:imports <http://onto.fel.cvut.cz/ontologies/s-pipes-lib> ;
  owl:imports z-sgov:model ;
.
:attach-advanced
  a sml:ApplyConstruct ;
  sm:next :question-siblings-ordering ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """#1 - add advanced questions if not important
CONSTRUCT {
     ?q  ft:has-importance ft:advanced .
}
WHERE {
    ?q a doc:question .
    FILTER NOT EXISTS {
        ?q ft:has-importance ft:important .
    }
    FILTER NOT EXISTS {
        ?q ft:has-importance ft:required .
    }
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-advanced" ;
.
:attach-answerable-section-logic
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# add visibility logic of questions related to answerable section
CONSTRUCT {
      ?qChild form:is-relevant-if ?cond .
      ?cond   a form:condition ;
             form:accepts-answer-value true ;
             form:has-tested-question ?qAnswerable ;
     .
}
WHERE {
    ?qAnswerable form-lt:has-layout-class \"answerable\" .
    ?qAnswerable doc:has_related_question ?qChild .
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?qChild), str(?qAnswerable))))) as ?cond)
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-answerable-section-logic" ;
.
:attach-descriptions
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# create descriptions
CONSTRUCT {
    ?q dce:description ?description .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    OPTIONAL {
        ?entity skos:definition ?definition .
    } .
    OPTIONAL {
        ?entity skos:scopeNote ?scopeNote .
    } .
    BIND (COALESCE(?definition, ?scopeNote) AS ?description)
}""" ;
    ] ;
  sml:replace false ;
.
:attach-duplicable-questions
  a sml:ApplyConstruct ;
  sm:next :construct-duplicate-questions ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?q :is-duplicable true .
}
WHERE {
	?q a doc:question .
    ?q :has-processing-entity ?entity .
   ?entity   ft:max-cardinality ?cardinality .
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-duplicable-questions" ;
.
:attach-duplicate-type-questions
  a sml:ApplyConstruct ;
  sm:next :attach-importance ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - construct copy of type questions
# TODO - not systematic, compute cardinality first
CONSTRUCT {
     ?parentQ doc:has_related_question ?duplicateChildQ .
     ?parentQ form:has-type-question ?duplicateChildQ .
     ?duplicateChildQ ?p ?o .
}
WHERE {

     VALUES ?card { 1 2 3 4 }

     ?parentQ form:has-type-question ?childQ .

# attach specific properties
     OPTIONAL {
          ?childQ ?p ?o .
          FILTER(?p != doc:has_related_question )
     }

     BIND(fl:create-q(?childQ, ?card) as ?duplicateChildQ)
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "attach-duplicate-type-questions" ;
.
:attach-identifier-to-section
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 -  add simple identifier to parent question
CONSTRUCT {
    ?q form:has-identifying-question ?IdQ .
}
WHERE {
    ?q doc:has_related_question ?idQ  .
    ?idQ form:has-question-origin ?entity .
    ?entity a ft:object-identifier-quality .
    FILTER NOT EXISTS {
           ?idQ doc:has_related_question ?notExistsQ  .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - add multilingual identifier to parent question
CONSTRUCT {
    ?q form:has-identifying-question ?I8nIdQ .
}
WHERE {
    ?q doc:has_related_question ?idQ  .
    ?idQ form:has-question-origin ?entity .
    ?entity a ft:object-identifier-quality .

    ?idQ doc:has_related_question ?I8nIdQ  .
    ?I8nIdQ  form:has-question-origin ft:language-czech .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "attach-identifier-to-section" ;
.
:attach-importance
  a sml:ApplyConstruct ;
  sm:next :attach-importance-closure ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - make root question important
CONSTRUCT {
     ?rootQ  ft:has-importance ft:important .
}
WHERE {
    ?formQ a doc:question .
    ?formQ doc:has_related_question ?rootQ .
    FILTER NOT EXISTS {
        ?notExistsQ doc:has_related_question ?formQ .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 3 - add  question importance from processing entity
CONSTRUCT {
     ?q  ft:has-importance ?importance .
}
WHERE {
    ?q a doc:question .
    ?q :has-processing-entity ?processingEntity .
    OPTIONAL {
        ?processingEntity ft:has-importance ?importance .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 4 - add question importance from processing relator
CONSTRUCT {
     ?q  ft:has-importance ?importance .
}
WHERE {
    ?q a doc:question .
    ?q :has-processing-relator ?processingRelator .
    OPTIONAL {
        ?processingRelator ft:has-importance ?importance .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 5 - add question importance from importance conditions
CONSTRUCT {
     ?q  ft:has-importance ?importance .
}
WHERE {
    ?qParent doc:has_related_question ?q .
    ?ic a ft:importance-condition  ;
          ft:has-importance ?importance ;
    .
    {
          ?qParent :has-processing-entity ?parentProcessingEntity .
          ?ic ft:has-parent-entity ?parentProcessingEntity .
    } UNION {
          ?qParent :has-processing-relator ?parentProcessingRelator .
          ?ic ft:has-parent-relator ?parentProcessingRelator .
    }
    {
           ?q :has-processing-entity ?processingEntity .
           ?ic ft:has-target-entity ?processingEntity .
    } UNION {
           ?q :has-processing-relator ?processingRelator .
           ?ic ft:has-target-relator ?processingRelator .
    }
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-importance" ;
.
:attach-importance-closure
  a sml:ApplyConstruct ;
  sm:next :attach-advanced ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# make all sibling question important by default
CONSTRUCT {
     ?q  ft:has-importance ft:important .
}
WHERE {
    ?qParent doc:has_related_question ?q .
    FILTER NOT EXISTS {
        ?qParent doc:has_related_question ?qNotExists .
        ?qNotExists  ft:has-importance ?importance .
    }
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-importance-closure" ;
.
:attach-possible-values-hook
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - possible values for internal queries
CONSTRUCT {
    ?question form:has-possible-values-query ?downloadString .
    ?question form-lt:has-layout-class \"type-ahead\" .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
        ?entity ft:external true .
    } .
    ?question form:has-question-origin ?entity .
    BIND (CONCAT(str(?formGenRepositoryUrl), \"?query=\") AS ?dowloadPrefix) .
    BIND (REPLACE(?possibleValuesQueryTemplate, \"XXXXX\", str(?entity)) AS ?downloadSuffixRaw) .
    BIND (ENCODE_FOR_URI(?downloadSuffixRaw) AS ?downloadSuffix) .
    BIND (CONCAT(?dowloadPrefix, ?downloadSuffix) AS ?downloadString)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - possible values for external queries
CONSTRUCT {
    ?question form:has-possible-values-query ?downloadString .
    ?question form-lt:has-layout-class \"type-ahead\" .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
		 ?codelistMapping a ft:codelist-mapping ;
              ft:has-codelist-service-url ?codeListServiceUrl  ;
              ft:has-codelist-entity ?codeListEntity ;
              ft:has-internal-entity ?entity  ;
          .
    } .

    ?question form:has-question-origin ?entity .
    BIND (CONCAT(str(?formGenRepositoryUrl), \"?query=\") AS ?dowloadPrefix) .
    BIND (REPLACE(?externalPossibleValuesQueryTemplate, \"XXX_SERVICE_XXX\", str(?codeListServiceUrl)) AS ?preparedPossibleValuesQueryTemplate) .
    BIND (REPLACE(?preparedPossibleValuesQueryTemplate, \"XXXXX\", str(?codeListEntity)) AS ?downloadSuffixRaw) .
    BIND (ENCODE_FOR_URI(?downloadSuffixRaw) AS ?downloadSuffix) .
    BIND (CONCAT(?dowloadPrefix, ?downloadSuffix) AS ?downloadString)
}""" ;
    ] ;
  sml:replace true ;
.
:attach-relevant-tested-questions
  a sml:ApplyConstruct ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - attach relevant tested questions based on type
CONSTRUCT {
     ?filteredQ :has-relevant-tested-question ?testedQ .
}
WHERE {
    ?q doc:has_related_question ?testedQ  .
    ?testedQ :has-processed-entity ?testedEntity .

    ?q doc:has_related_question ?filteredQ .
    ?filteredQ :has-processing-entity ?aspect .
    ?filteredQ :has-related-entity ?filteredEntity .
    ?testedEntity rdfs:subClassOf*  ?filteredEntity .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - attach not relevant tested questions based on type
CONSTRUCT {
     ?filteredQ :has-not-relevant-tested-question ?testedQ .
}
WHERE {
    ?q doc:has_related_question ?testedQ  .
    ?testedQ :has-processed-entity ?testedEntity .

    ?q doc:has_related_question ?filteredQ .
    ?filteredQ :has-processing-entity ?aspect .
    ?filteredQ :has-related-entity ?filteredEntity .
    FILTER NOT EXISTS {
         ?testedEntity rdfs:subClassOf*  ?filteredEntity .
    }
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-relevant-tested-questions" ;
.
:attach-root-question
  a sml:ApplyConstruct ;
  sm:next :construct-question-origins ;
  sm:next :construct-subquestions ;
  sm:next :merge-with-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 0 - create root-subquestion question
CONSTRUCT {
    ?rootQ a doc:question .
    ?rootQ rdfs:label ?rootEntityLabel .
    ?rootQ :has-processing-entity ?rootEntity .
}
WHERE {
    ?rootEntity skos:prefLabel ?rootEntityLabel .
    BIND (fl:create-q(CONCAT(str(?rootEntity)),?executionId) AS ?rootQ) .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - create root question
CONSTRUCT {
    ?formQ a doc:question .
    ?formQ rdfs:label ?formLabel .
    ?formQ form:has-question-origin ?formEntity .
    ?formQ doc:has_related_question ?rootQ .
}
WHERE {
    ?rootEntity skos:prefLabel ?rootEntityLabel .
    BIND (fl:create-q(CONCAT(str(?rootEntity)),?executionId) AS ?rootQ) .
    BIND (fl:create-q(CONCAT(str(?rootEntity), \"-form\"),?executionId) AS ?formQ) .
    BIND (CONCAT(str(?rootEntityLabel), \"-form\") AS ?formLabel) .
    BIND (IRI(CONCAT(str(?rootEntity), \"-form\")) AS ?formEntity) .
}""" ;
    ] ;
  sml:replace false ;
.
:attach-transitive-vocabulary-dependencies
  a sml:ApplyConstruct ;
  sm:next :construct-related-dataset-iris ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
   ?dependantVocab popis-dat-pojem:používá-pojmy-ze-slovníku ?usedVocab .
}
WHERE {
   ?dependantVocab popis-dat-pojem:používá-přímo-pojmy-ze-slovníku+ ?usedVocab .
}""" ;
    ] ;
.
:attach-type-questions-possible-values
  a sml:ApplyConstruct ;
  sm:next :attach-value-types ;
  sm:next :construct-possible-value-broader-relations ;
  sm:next :construct-type-filters ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct possible values for parent of type question
# TODO revise
CONSTRUCT {
    ?q form:has-possible-value ?subTypeEntity .
    ?subTypeEntity rdfs:label ?subTypeEntityLabel .
    ?q form-lt:has-layout-class \"answerable\" .
    ?q form-lt:has-layout-class \"type-question\" .

    ?q form:has-possible-value ?typeEntity .
    ?typeEntity rdfs:label ?typeEntityLabel .
}
WHERE {
     ?q form:has-type-question ?typeQ .
     ?typeQ :has-processed-entity ?typeEntity .
     ?subTypeEntity rdfs:subClassOf+  ?typeEntity .
     ?subTypeEntity skos:prefLabel ?subTypeEntityLabel .

      ?typeEntity skos:prefLabel ?typeEntityLabel .
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-type-questions-possible-values" ;
.
:attach-value-types
  a sml:ApplyConstruct ;
  sm:next :attach-descriptions ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# boolean
CONSTRUCT {
    ?q form-lt:has-layout-class \"checkbox\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a ft:boolean .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# date
CONSTRUCT {
    ?q form-lt:has-layout-class \"masked-input\" .
    ?q form:has-input-mask \"DD/MM/YYYY\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a ft:date .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# datetime
CONSTRUCT {
    ?q form-lt:has-layout-class \"datetime\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a ft:datetime .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# initial lenght of input text field
CONSTRUCT {
    ?q  form-lt:has-initial-input-length ?answerSize .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity ft:has-initial-input-length ?answerSize .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# number
CONSTRUCT {
    ?q form-lt:has-layout-class \"number\" .
    ?q form:has-datatype xsd:int .
    ?q xsd:minInclusive ?minInclusive  .
    ?q xsd:maxInclusive ?maxInclusive .
    ?q form:step ?step .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a ft:number .
    OPTIONAL {
          ?entity xsd:minInclusive ?minInclusiveOptional .
    }
    OPTIONAL {
          ?entity xsd:maxInclusive ?maxInclusiveOptional .
    }
    OPTIONAL {
          ?entity ft:step ?stepOptional .
    }
    BIND(coalesce(?minInclusiveOptional, 0) as ?minInclusive)
    BIND(coalesce(?maxInclusiveOptional, 10000) as ?maxInclusive)
    BIND(coalesce(?stepOptional, 1) as ?step)

}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# textarea
CONSTRUCT {
    ?q form-lt:has-layout-class \"textarea\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a ft:textarea .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# textarea for multilingual TODO
CONSTRUCT {
    ?qChild form-lt:has-layout-class \"textarea\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?q doc:has_related_question ?qChild .
    ?entity a ft:textarea .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# time
CONSTRUCT {
    ?q form-lt:has-layout-class \"time\" .
}
WHERE {
    ?q a doc:question .
    ?q form:has-question-origin ?entity .
    ?entity a ft:time .
}""" ;
    ] ;
  sml:replace false ;
.
:bind-default-language
  a sml:BindWithConstant ;
  sm:next :construct-dny-v-tydnu-questions ;
  sm:outputVariable "defaultLanguage" ;
  sml:value "cs" ;
  rdfs:label "bind-default-language" ;
.
:bind-execution-id
  a sml:BindBySelect ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# multiple root questions exists
ASK
WHERE {
           ?qRoot1 a doc:question .
           FILTER NOT EXISTS {
                 ?qNE1 a doc:question .
                 ?qNE1 doc:has_related_question ?qRoot1 .
           }
           ?qRoot2 a doc:question .
           FILTER NOT EXISTS {
                 ?qNE2 a doc:question .
                 ?qNE2 doc:has_related_question ?qRoot2 .
           }
           FILTER(?qRoot1 != ?qRoot2)
}""" ;
      sp:where (
          [
            sp:object doc:question ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "qRoot1" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object doc:question ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "qNE1" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "qRoot1" ;
                        ] ;
                      sp:predicate doc:has_related_question ;
                      sp:subject [
                          sp:varName "qNE1" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            sp:object doc:question ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "qRoot2" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object doc:question ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "qNE2" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "qRoot2" ;
                        ] ;
                      sp:predicate doc:has_related_question ;
                      sp:subject [
                          sp:varName "qNE2" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:ne ;
                sp:arg1 [
                    sp:varName "qRoot1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "qRoot2" ;
                  ] ;
              ] ;
          ]
        ) ;
      rdfs:comment "multiple root questions exists" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# root quesiton is bound but does not have recognizable IRI
ASK WHERE {
      ?qRoot a doc:question .
      FILTER NOT EXISTS {
            ?qNE a doc:question .
            ?qNE doc:has_related_question ?qRoot .
       }
      FILTER (!regex(str(?qRoot), \"^.*-form-.*-q$\")) .
}""" ;
    ] ;
  sm:next :bind-form-template-service-url ;
  sm:next :bind-sample-form-uri ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """# bind executionId based on root question or generate new
SELECT ?executionId
WHERE {
    OPTIONAL {
        ?qRoot a doc:question .
        FILTER NOT EXISTS {
            ?qNE a doc:question .
            ?qNE doc:has_related_question ?qRoot .
        } .
        BIND (REPLACE(REPLACE(str(?qRoot), \"^.*form-\", \"\"), \"-q$\", \"\") AS ?inferredExecutionId) .
    } .
    BIND (COALESCE(?_DexecutionId, ?inferredExecutionId, STRUUID()) AS ?executionId) .
}""" ;
    ] ;
  rdfs:label "bind-execution-id" ;
.
:bind-external-possible-values-query-template
  a sml:BindWithConstant ;
  sm:next :attach-possible-values-hook ;
  sm:outputVariable "externalPossibleValuesQueryTemplate" ;
  sml:value """prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix dce: <http://purl.org/dc/elements/1.1/>
prefix form: <http://onto.fel.cvut.cz/ontologies/form/>

CONSTRUCT {
      # TODO remove
      <http://publications.europa.eu/resource/authority/currency/AFA> form:has-preceding-value <http://publications.europa.eu/resource/authority/currency/CZK> .
      <http://publications.europa.eu/resource/authority/currency/AFA> form:has-preceding-value <http://publications.europa.eu/resource/authority/currency/EUR> .
      <http://publications.europa.eu/resource/authority/currency/AFA> form:has-preceding-value <http://publications.europa.eu/resource/authority/currency/USD> .
      ?value rdfs:label ?labelStr .
      ?value rdfs:comment ?explanationStr .
}
WHERE {
  SERVICE   <XXX_SERVICE_XXX>  {
     SELECT ?value ?labelStr ?explanationStr ?entityType {

          VALUES (?entityType) {
               (<XXXXX>)
          }

          ?value skos:inScheme ?entityType .

          ?value skos:prefLabel ?label .
          FILTER ( lang(?label) = \"cs\" )
          BIND(str(?label) as ?labelStr)

          OPTIONAL {
              ?value dce:description ?explanation .
              FILTER ( lang(?explanation) = \"cs\" )
              BIND(str(?explanation) as ?explanationStr)
          }

      }
  }
}""" ;
  rdfs:label "bind-external-possible-values-query-template" ;
.
:bind-form-template
  a sml:BindBySelect ;
  sm:next :bind-form-template-service-url ;
  sm:next :bind-sample-form-uri ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?formTemplate
WHERE {
    OPTIONAL {
         ?r <http://vfn.cz/ontologies/study-manager/has-form-template> ?formTemplateStr .
    }
    BIND (COALESCE(?_DformTemplate, str(?formTemplateStr)) AS ?formTemplate) .
}""" ;
    ] ;
.
:bind-form-template-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-form-template ;
  sm:outputVariable "formMetadataServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "formTemplate" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:bind-possible-values-query-template
  a sml:BindWithConstant ;
  sm:next :attach-possible-values-hook ;
  sm:outputVariable "possibleValuesQueryTemplate" ;
  sml:value """prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
CONSTRUCT {
      ?value rdfs:label ?label .
      ?value rdfs:comment ?explanation .
}
WHERE {
          ?value rdfs:label ?label .
          ?value rdfs:comment ?explanation .
          ?value a ?entityType .
}
VALUES (?entityType) {
      (<XXXXX>)
}""" ;
.
:bind-record-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-record-graph ;
  sm:outputVariable "recordServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "recordGraphId" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:bind-root-entity
  a sml:BindBySelect ;
  sm:next :attach-root-question ;
  sm:next :construct-related-dataset-iris ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?rootEntity
WHERE {
    ?rootEntity a ft:root-entity .
}""" ;
    ] ;
.
:bind-root-question
  a sml:BindBySelect ;
  sm:next :layout-form ;
  sml:selectQuery [
      a sp:Select ;
      sp:text """SELECT ?rootQuestion
WHERE {
    ?rootQuestion a doc:question .
    FILTER NOT EXISTS {
        ?superQuestion doc:has_related_question ?rootQuestion .
        ?superQuestion a doc:question .
    }
}""" ;
    ] ;
.
:bind-sample-form-service-url
  a sml:BindWithConstant ;
  sm:next :retrieve-sample-form ;
  sm:outputVariable "sampleFormServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formGenRepositoryUrl" ;
                ] ;
            ] ;
          sp:arg2 "?default-graph-uri=" ;
          sp:arg3 [
              a sp:encode_for_uri ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "sampleFormUri" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
  rdfs:label "bind-sample-form-service-url" ;
.
:bind-sample-form-uri
  a sml:BindWithConstant ;
  sm:next :bind-sample-form-service-url ;
  sm:next :deploy-sample-form ;
  sm:outputVariable "sampleFormUri" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:concat ;
          sp:arg1 [
              a sp:str ;
              sp:arg1 [
                  sp:varName "formTemplate" ;
                ] ;
            ] ;
          sp:arg2 "--sample-form" ;
        ] ;
    ] ;
  rdfs:label "bind-sample-form-uri" ;
.
:bind-sgov-service-url
  a sml:BindWithConstant ;
  sm:next :construct-direct-vocabulary-dependencies ;
  sm:next :retrieve-sgov ;
  sm:outputVariable "sgovServiceUrl" ;
  sml:value [
      a sp:iri ;
      sp:arg1 [
          a sp:coalesce ;
          sp:arg1 [
              sp:varName "sgovRepositoryUrl" ;
            ] ;
          sp:arg2 [
              a sp:concat ;
              sp:arg1 [
                  a sp:str ;
                  sp:arg1 [
                      sp:varName "formGenRepositoryUrl" ;
                    ] ;
                ] ;
              sp:arg2 "?default-graph-uri=" ;
              sp:arg3 [
                  a sp:encode_for_uri ;
                  sp:arg1 [
                      a sp:str ;
                      sp:arg1 <http://onto.fel.cvut.cz/ontologies/sgov-data> ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
.
:clone
  a sm:Function ;
  sm:returnModule :clone_Return ;
  rdfs:subClassOf sm:Functions ;
.
:clone_Return
  a sml:ReturnRDF ;
  sml:serialization sml:Turtle ;
.
:construct-direct-vocabulary-dependencies
  a sml:ApplyConstruct ;
  sm:next :attach-transitive-vocabulary-dependencies ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
     ?dependantVocab popis-dat-pojem:používá-přímo-pojmy-ze-slovníku ?usedVocab .
} WHERE {
   SERVICE ?sgovServiceUrl {
      GRAPH ?dependantVocab {
           ?dependantVocab	a popis-dat-pojem:slovník	.
           ?s ?p ?usedConcept .
       }
       GRAPH ?usedVocab {    	
          ?usedVocab a popis-dat-pojem:slovník	.
          ?usedConcept skos:inScheme ?importedGlosary .
        }
        FILTER(?dependantVocab != ?usedVocab)
   }
}""" ;
    ] ;
.
:construct-dny-v-tydnu-questions
  a sml:ApplyConstruct ;
  sm:next :attach-duplicable-questions ;
  sm:next :question-siblings-ordering ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# TODO remove layout class
CONSTRUCT {
      ?childQ a doc:question .
      ?childQ rdfs:label ?valueLabel .
      ?childQ form:has-question-origin ?value .
      ?childQ  :has-processing-relator rdf:type .
      ?childQ form-lt:has-layout-class \"checkbox\" .
      ?parentQ doc:has_related_question ?childQ .
}
WHERE {
   #TODO remove constants
   BIND(<https://slovník.gov.cz/generický/číselníky/pojem/den-v-týdnu> as ?parentEntity)

    ?parentQ form:has-question-origin ?parentEntity .

    ?codelistMapping a ft:codelist-mapping ;
        ft:has-codelist-service-url ?codeListServiceUrl  ;
        ft:has-codelist-entity ?codeListEntity ;
        ft:has-internal-entity ?parentEntity  ;
     .

    SERVICE ?codeListServiceUrl {
            ?value skos:inScheme ?codeListEntity .
            ?value skos:prefLabel ?valueLabel .
    }
   BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
   BIND (fl:create-q(str(?value),?childExecutionId) AS ?childQ) .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-dny-v-tydnu-questions" ;
.
:construct-duplicate-questions
  a sml:ApplyConstruct ;
  kbss-module:has-max-iteration-count "1" ;
  sm:next :attach-importance ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - construct deep copy of questions
# TODO - not systematic
CONSTRUCT {
     ?qRootParent doc:has_related_question ?qRootX .
     ?qDescendantX doc:has_related_question ?qDescendantChildX .
     ?qDescendantX ?p ?o .
}
WHERE {

     VALUES ?card { 1 2 3 4 }

     ?qRoot :is-duplicable true .
     ?qRoot doc:has_related_question* ?qDescendant .

# attach to root
     ?qRootParent doc:has_related_question ?qRoot .

# construct doc:has_related_question taxonomy
     OPTIONAL {
         ?qDescendant doc:has_related_question ?qDescendantChild .
     }

# attach specific properties
     OPTIONAL {
          ?qDescendant ?p ?o .
          FILTER(?p != doc:has_related_question )
     }

     BIND(fl:create-q(?qRoot, ?card) as ?qRootX)
     BIND(fl:create-q(?qDescendant, ?card) as ?qDescendantX)
     BIND(fl:create-q(?qDescendantChild, ?card) as ?qDescendantChildX)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 -  construct hiding logic and ordering
# todo make is-relevant-if automatic from an attribute
CONSTRUCT {
      ?qRoot form-lt:has-layout-class \"answerable\" .
      ?qRoot form-lt:has-layout-class \"checkbox\" .

      ?qRootX form-lt:has-layout-class \"answerable\" .
      ?qRootX form-lt:has-layout-class \"checkbox\" .

     ?qRootX a form:relator-multiplicity-question .
     ?qRootP a form:relator-multiplicity-question .
     ?precedenceP a form:relator-multiplicity-precedence ;
             form:has-first-question ?qRootP ;
             form:has-second-question ?qRootX ;
     .
     ?qRootX form:has-preceding-question  ?qRootP .

     ?qRootX form:is-relevant-if  ?condP .
     ?condP   a form:condition ;
             form:accepts-answer-value true ;
             form:has-tested-question ?qRootP ;
    .
}
WHERE {
    VALUES ?card { 1 2 3 4 }

    ?qRoot :is-duplicable true .

    BIND(fl:create-q(?qRoot, ?card) as ?qRootX)
    BIND( IF(?card=1, ?qRoot, fl:create-q(?qRoot, ?card-1)) as ?qRootP)

    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?qRootX), str(?qRootP))))) as ?condP)
    BIND(IRI(concat(str(form:relator-multiplicity-precedence), \"-\", md5(concat(str(?qRootX), str(?qRootP))))) as ?precedenceP)
}""" ;
    ] ;
  rdfs:label "construct-duplicate-questions" ;
.
:construct-metaquestions
  a sml:ApplyConstruct ;
  sm:next :attach-answerable-section-logic ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct show advanced quesitons and ordering
# TODO - remove form-layout
CONSTRUCT {
     ?parentQ doc:has_related_question ?showAdvancedQ .
     ?showAdvancedQ a doc:question ;
          rdfs:label \"Zobrazit více\" ;
          dce:description \"Zobrazí/Skryje pokročilé otázky. Otázky,  které jsou zodpovězeny a sekce, které obsahují zodpovězené otázky nelze skrýt.\" ;
          form-lt:has-layout-class \"checkbox\" ;
          form:has-question-origin form:show-advanced-question ;
          form:show-advanced-question true ;
      .
      ?q form:is-relevant-if ?orCondition .
      ?orCondition a form:or-condition ;
             form:has-sub-condition ?condShowAdvanced ;
             form:has-sub-condition ?condHasAnswer ;
      .
      ?condShowAdvanced   a form:condition ;
             form:has-tested-question ?showAdvancedQ ;
             form:accepts-answer-value true ;
      .
      ?condHasAnswer   a form:condition ;
             form:has-tested-question ?q ;
             form:accepts form:answered-question ;
      .

     ?q form-lt:has-layout-class \"emphasise-on-relevant\" .
# TODO  do specific metadata questions ordering
      ?showAdvancedQ a form:meta-question .
      ?q form:has-preceding-question ?showAdvancedQ .
}
WHERE {
    ?parentQ doc:has_related_question ?advancedQ .
    ?advancedQ ft:has-importance ft:advanced .
    ?parentQ doc:has_related_question ?q  .
    ?q ft:has-importance ft:advanced .


    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(form:show-advanced-question),?childExecutionId) AS ?showAdvancedQ)
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?parentQ), str(?showAdvancedQ))))) as ?condShowAdvanced)
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?showAdvancedQ), str(?q))))) as ?condHasAnswer)
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?showAdvancedQ), str(?q), str(?parentQ))))) as ?orCondition)

}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-metaquestions" ;
.
:construct-possible-value-broader-relations
  a sml:ApplyConstruct ;
  sm:next :construct-type-filters ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct possible values for parent of type question
# TODO revise
CONSTRUCT {
    ?subTypeEntity skos:broader  ?superTypeEntity  .
}
WHERE {
     ?q form:has-type-question ?typeQ .
     ?q form:has-possible-value ?subTypeEntity .
     ?q form:has-possible-value ?superTypeEntity .

     ?subTypeEntity rdfs:subClassOf  ?superTypeEntity .
}""" ;
    ] ;
  rdfs:label "construct-possible-value-broader-relations" ;
.
:construct-question-based-origins
  a sml:ApplyConstruct ;
  sm:next :filter-out-form-template-configuration ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?q form:has-question-origin ?qo .
}
WHERE {
    ?q a doc:question .
    BIND(fl:create-qo(?q) as ?qo)
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-question-based-origins" ;
.
:construct-question-origins
  a sml:ApplyConstruct ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# question has multipe origins
ASK
WHERE {
     ?q  form:has-question-origin ?qO1 .
     ?q  form:has-question-origin ?qO2 .
     FILTER(?qO1 != ?qO2)
}""" ;
    ] ;
  sm:next :merge-with-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct from processed entities
CONSTRUCT {
   ?q form:has-question-origin ?qO .
}
WHERE {
    ?q :has-processed-entity ?qO .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# construct from processing entities
CONSTRUCT {
   ?q form:has-question-origin ?qO .
}
WHERE {
    ?q :has-processing-entity ?qO .
    FILTER NOT EXISTS {
              ?q :has-processing-entity ?qONotExists .
              ?qO rdfs:subClassOf+ ?qONotExists .
    }
}""" ;
    ] ;
  sml:replace true ;
.
:construct-related-dataset-iris
  a sml:ApplyConstruct ;
  sm:next :retrieve-related-datasets ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?rootEntity :related-dataset ?usedVocab .
    ?rootEntity :related-dataset ?vocabulary .
}
WHERE {
     SERVICE ?sgovServiceUrl {
        ?rootEntity skos:inScheme ?glosary .
        ?vocabulary a-popis-dat-pojem:má-glosář ?glosary .
        ?vocabulary a-popis-dat-pojem:má-model ?model .
     }

     ?vocabulary popis-dat-pojem:používá-pojmy-ze-slovníku ?usedVocab .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-related-dataset-iris" ;
.
:construct-subquestions
  a sml:ApplyConstruct ;
  kbss-module:has-max-iteration-count "5" ;
  sm:next :construct-question-origins ;
  sm:next :merge-with-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - add intrinsic tropes
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeLabel .
    ?childQ :has-processing-entity ?trope .
    ?childQ :has-related-entity ?parentEntity .
    ?parentQ doc:has_related_question ?childQ .
    ?childQ a form:trope-question .
}
WHERE {
    ?trope a z-sgov-pojem:typ-vlastnosti .
    ?trope rdfs:subClassOf/owl:someValuesFrom ?parentEntity .
    ?trope skos:prefLabel ?tropePrefLabel .
    OPTIONAL {
        ?trope skos:altLabel ?tropeAltLabel .
    } .
    BIND (fl:capitalize-first-letter(COALESCE(?tropeAltLabel, ?tropePrefLabel)) AS ?tropeLabel) .
    ?parentQ :has-processing-entity ?directParentEntity .
    ?directParentEntity rdfs:subClassOf* ?parentEntity .
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(?trope),?childExecutionId) AS ?childQ) .
    FILTER NOT EXISTS {
        ?trope ft:ignore true .
    } .
    FILTER NOT EXISTS {
        ?parentEntity ft:ignore true .
    } .
    FILTER NOT EXISTS {
        ?parentEntity ft:external true .
    }
    FILTER NOT EXISTS {
        ?ic a ft:ignore-condition ;
              ft:has-parent-entity ?directParentEntity  ;
              ft:has-target-entity ?trope  ;
        .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - add relators
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?relatorLabel .
    ?childQ :has-processing-entity ?childEntity .
    ?childQ :has-processing-relator ?relator .
    ?childQ :has-related-entity ?parentEntity .
    ?parentQ doc:has_related_question ?childQ .
    ?childQ a form:relator-question .
}
WHERE {
    ?relator a z-sgov-pojem:typ-vztahu .
    ?relator skos:prefLabel ?relatorPrefLabel .
    ?relator rdfs:subClassOf ?parentRestriction .
    ?relator rdfs:subClassOf ?childRestriction .
    OPTIONAL {
        ?relator skos:altLabel ?relatorAltLabel .
    } .
    BIND (fl:capitalize-first-letter(COALESCE(?relatorAltLabel, ?relatorPrefLabel)) AS ?relatorLabel) .
    ?parentRestriction owl:onProperty z-sgov-pojem:má-vztažený-prvek-1 .
    ?parentRestriction owl:someValuesFrom ?parentEntity .
    ?childRestriction owl:onProperty z-sgov-pojem:má-vztažený-prvek-2 .
    ?childRestriction owl:someValuesFrom ?childEntity .
    ?parentQ :has-processing-entity ?directParentEntity .
    ?directParentEntity rdfs:subClassOf* ?parentEntity .
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(?relator),?childExecutionId) AS ?childQ) .
    FILTER (?parentEntity != ?childEntity) .
    FILTER NOT EXISTS {
        ?relator ft:ignore true .
    }
    FILTER NOT EXISTS {
        ?parentEntity ft:ignore true .
    }
    FILTER NOT EXISTS {
        ?parentEntity ft:external true .
    }
    FILTER NOT EXISTS {
        ?ic a ft:ignore-condition ;
              ft:has-parent-entity ?directParentEntity  ;
              ft:has-target-entity ?childEntity  ;
        .
    }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 3 - add questions for more specific subclasses
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label \"Typ\"  .
    ?childQ :has-processed-entity ?parentEntity .
    ?parentQ doc:has_related_question ?childQ .
    # TODO should not be here
    ?parentQ form:has-type-question ?childQ .
}
WHERE {
     ?parentQ :has-processing-entity ?parentEntity .
     ?moreSpecificEntity rdfs:subClassOf+ ?parentEntity   .
     BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
     BIND (fl:create-q(concat(str(?parentEntity),\"-type-\"), ?childExecutionId) AS ?childQ) .
     FILTER NOT EXISTS {
          ?moreSpecificEntity ft:ignore true .
      }
      FILTER NOT EXISTS {
          ?parentEntity ft:ignore true .
       }
      FILTER NOT EXISTS {
          ?parentEntity ft:external true .
      }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 4 - propagate processed entities to parent question
CONSTRUCT {
     ?parentQ :has-processing-entity ?qO  .
}
WHERE {
    ?parentQ doc:has_related_question ?childQ .
    ?childQ :has-processed-entity ?qO .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 5 - add question for value of complex trope
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeValueLabel .
    ?childQ :has-processing-entity ?tropeValue .
# TODO related-entity cannot be applied
#  ?childQ :has-related-entity ?trope .
     ?parentQ doc:has_related_question ?childQ .
} WHERE {
     ?trope a z-sgov-pojem:typ-vlastnosti .
     ?parentQ :has-processing-entity ?trope .
     ?parentQ doc:has_related_question ?filteringQ .
     ?filteringQ :has-processed-entity ?qO .
     FILTER NOT EXISTS {
              ?parentQ :has-processing-entity ?tropeNotExists .
              ?trope rdfs:subClassOf+ ?tropeNotExists .
      }

     BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
     BIND(IRI(concat(str(?trope),\"-value\")) as ?tropeValue)
     BIND (fl:create-q(str(?tropeValue),?childExecutionId) AS ?childQ) .
     BIND(\"Hodnota\" as ?tropeValueLabel)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 7 - add multilingual labels
# TODO refactor
CONSTRUCT {
    ?childQ a doc:question .
    ?childQ rdfs:label ?tropeLabel .
    ?childQ :has-processing-entity ?trope .
    ?childQ :has-related-entity ?parentEntity .
    ?parentQ doc:has_related_question ?childQ .
}
WHERE {
	?parentQ  :has-processing-entity ?parentEntity  .
    ?parentEntity a ft:multilingual-quality .
    ?trope a ft:language .
    ?trope  skos:prefLabel ?tropeLabel .
    BIND(md5(concat(str(?parentQ),?executionId)) as ?childExecutionId)
    BIND (fl:create-q(str(?trope),?childExecutionId) AS ?childQ) .
    FILTER NOT EXISTS {
        ?trope ft:ignore true .
    } .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 8 - extend question processing entities by most specific subclasses
CONSTRUCT {
     ?q :has-processing-entity ?mostSpecificEntity .
} WHERE {
     ?q :has-processing-entity ?entity .
     ?mostSpecificEntity rdfs:subClassOf+ ?entity   .
     FILTER NOT EXISTS {
       ?notExistMoreSpecificEntity rdfs:subClassOf ?mostSpecificEntity .
     }
}
""" ;
    ] ;
  sml:replace true ;
.
:construct-type-filters
  a sml:ApplyConstruct ;
  sm:next :attach-value-types ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2- filtering of tropes and relators based on type
CONSTRUCT {
     ?filteredQ form:is-relevant-if  ?orCondition .
     ?filteredQ form-lt:has-layout-class \"emphasise-on-relevant\" .
     ?orCondition a form:or-condition ;
             form:has-sub-condition ?testedQCondition ;
      .
      ?testedQCondition a form:condition ;
           form:accepts-answer-value ?testedEntity ;
           form:has-tested-question ?testedQ ;
      .
}
WHERE {
    ?q form:has-type-question ?testedQ .
    ?q doc:has_related_question ?filteredQ .
    ?q form:has-possible-value ?testedEntity .

    ?filteredQ :has-processing-entity ?aspect .
    ?filteredQ :has-related-entity ?filteredEntity .
    ?testedEntity rdfs:subClassOf*  ?filteredEntity .

    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?filteredQ), \"filtering-based-on-type\")))) as ?orCondition)
    BIND(IRI(concat(str(form:condition), \"-\", md5(concat(str(?filteredQ), str(?testedQ), \"filtering-based-on-type\")))) as ?testedQCondition)
}""" ;
    ] ;
  sml:replace true ;
.
:construct-unit-of-measure-questions
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# add reference to unit of measure from quality question
CONSTRUCT {
     ?qQualityValue form:has-unit-of-measure-question ?qUnitOfMeasure .
}
WHERE {
    ?qualityValueEntity ft:has-unit-of-measure ?unitOfMeasureEntity .

    ?qParent doc:has_related_question ?qUnitOfMeasure .
    ?qUnitOfMeasure  :has-processing-entity ?unitOfMeasureEntity .
    ?qParent doc:has_related_question ?qQualityValue .
    ?qQualityValue  :has-processing-entity ?qualityValueEntity .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "construct-unit-of-measure-questions" ;
.
:deploy-sample
  a sm:Function ;
  sm:returnModule :deploy-sample_Return ;
  rdfs:subClassOf sm:Functions ;
.
:deploy-sample-form
  a kbss-module:deploy ;
  km-rdf4j:p-is-replace true ;
  km-rdf4j:p-rdf4j-context-iri [
      a sp:str ;
      sp:arg1 [
          sp:varName "sampleFormUri" ;
        ] ;
    ] ;
  km-rdf4j:p-rdf4j-repository-name [
      a sp:replace ;
      sp:arg1 [
          sp:varName "formGenRepositoryUrl" ;
        ] ;
      sp:arg2 ".*/repositories/" ;
      sp:arg3 "" ;
    ] ;
  km-rdf4j:p-rdf4j-server-url [
      a sp:replace ;
      sp:arg1 [
          sp:varName "formGenRepositoryUrl" ;
        ] ;
      sp:arg2 "/repositories/.*" ;
      sp:arg3 "" ;
    ] ;
  sm:next :deploy-sample_Return ;
  rdfs:label "deploy-sample-form" ;
.
:deploy-sample_Return
  a sml:ReturnRDF ;
  sml:serialization sml:Turtle ;
.
:filter-out-form-template-configuration
  a sml:ApplyConstruct ;
  sm:next :deploy-sample-form ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o
}
WHERE {
     ?s ?p ?o .
     FILTER(?o !=  ft:root-entity)
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "filter-out-form-template-configuration" ;
.
:filter-out-question-origins
  a sml:ApplyConstruct ;
  sm:next :construct-question-based-origins ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
     ?s ?p ?o .
}
WHERE {
     ?s ?p ?o .
     FILTER(?p != form:has-question-origin)
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "filter-out-question-origins" ;
.
:has-algorithm-related-property
  a rdf:Property ;
.
:has-processed-entity
  a rdf:Property ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:has-processing-entity
  a owl:ObjectProperty ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:has-processing-relator
  a owl:ObjectProperty ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:has-related-entity
  a owl:ObjectProperty ;
  rdfs:subPropertyOf :has-algorithm-related-property ;
.
:ignore-cycles
  a sml:ApplyConstruct ;
  sm:next :construct-subquestions ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# Ignore entities that would cause cycles
CONSTRUCT {
     ?entity ft:ignore true .
}
WHERE {

} VALUES (?entity) {
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-konec>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-začátek>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-lokalizaci>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/má-kontext>)
    (<https://slovník.gov.cz/veřejný-sektor/pojem/opakovaná-časová-specifikace>)
    (<https://slovník.gov.cz/generický/částky/pojem/jednotková-částka>)
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# v modelu Částky dvě entity ukazují na stejnou vlastnost se stejnou kardinalitou
CONSTRUCT {
     ?entity ft:ignore true .
}
WHERE {

} VALUES (?entity) {
    (<https://slovník.gov.cz/generický/částky/pojem/jednotková-částka>)
}""" ;
    ] ;
.
:layout-form
  a sml:ApplyConstruct ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 0 - create form layout question
CONSTRUCT {
    ?rootQuestion form-lt:has-layout-class \"form\" .
}
WHERE {
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - create section layout classes
CONSTRUCT {
    ?sectionQuestion form-lt:has-layout-class \"section\" .
    ?sectionQuestion form-lt:has-layout-class \"collapsed\" .
}
WHERE {
    ?sectionQuestion doc:has_related_question ?subQuestion .
    FILTER (?rootQuestion != ?sectionQuestion) .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 2 - create wizard step layout for top level sections
CONSTRUCT {
    ?topSectionQuestion form-lt:has-layout-class \"wizard-step\" .
    ?topSectionQuestion form-lt:has-layout-class \"section\" .
    ?topSectionQuestion form-lt:has-layout-class \"sticky\" .
}
WHERE {
    ?rootQuestion doc:has_related_question ?topSectionQuestion .
}""" ;
    ] ;
  sml:replace true ;
  rdfs:label "Layout form" ;
.
:merge
  a sml:Merge ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# root question does not have any subquestions
ASK WHERE {
    ?rootQuestion form-lt:has-layout-class \"form\" .
    FILTER NOT EXISTS {
        ?rootQuestion doc:has_related_question ?subQuestion .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there a sibling parents having same origin
ASK WHERE {
#    ?qParent doc:has_related_question ?q1 .
#   ?qParent doc:has_related_question ?q2 .
#    ?q1 form:has-question-origin ?qO1 .
#    ?q2 form:has-question-origin ?qO2 .
     FILTER(false) # TODO
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question with more than one answer
ASK WHERE {
    ?q a doc:question .
    ?q doc:has_answer ?a1 .
    ?q doc:has_answer ?a2 .
    FILTER (?a1 != ?a2)
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question with two parent question
ASK
WHERE {
    ?parentQ1 doc:has_related_question ?q .
    ?parentQ2 doc:has_related_question ?q .
    FILTER(?parentQ1 != ?parentQ2)
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question without a label
ASK WHERE {
    ?question a doc:question .
    FILTER NOT EXISTS {
        ?question rdfs:label ?label .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is a question without specified question origin
ASK WHERE {
    ?question a doc:question .
    FILTER NOT EXISTS {
        ?question form:has-question-origin ?origin .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is an empty section within the form
ASK WHERE {
    ?sectionQ form-lt:has-layout-class \"section\" .
    FILTER NOT EXISTS {
        ?sectionQ doc:has_related_question ?subQ .
    }
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is asserted ordering between questions that does not have same parent
ASK WHERE {
    ?q2 form:has-preceding-question ?q1 .
    FILTER NOT EXISTS {
        ?qParent doc:has_related_question ?q1 .
        ?qParent doc:has_related_question ?q2 .
    } .
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is cycle in has-preceding-quesiton relation
ASK WHERE {
    ?q1 form:has-preceding-question ?q2 .
    ?q2 (form:has-preceding-question)* ?q1 .
}""" ;
    ] ;
  kbss-module:has-input-graph-constraint [
      a sp:Ask ;
      sp:text """# there is no \"form\" element
ASK WHERE {
    FILTER NOT EXISTS {
        ?s form-lt:has-layout-class \"form\" .
    }
}""" ;
    ] ;
  sm:next :filter-out-question-origins ;
  sm:next :transform_Return ;
.
:merge-form-metadata
  a kbss-module:merge-form-metadata ;
  kbss-module:execution-id [
      sp:varName "executionId" ;
    ] ;
  sm:next :clone_Return ;
  sml:replace true ;
  rdfs:label "merge-form-metadata" ;
.
:merge-with-origins
  a sml:Merge ;
  sm:next :attach-duplicable-questions ;
  sm:next :attach-duplicate-type-questions ;
  sm:next :attach-importance ;
  sm:next :construct-dny-v-tydnu-questions ;
  rdfs:label "merge-with-origins" ;
.
:question-siblings-ordering
  a sml:ApplyConstruct ;
  kbss-module:has-max-iteration-count 10 ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# 0 - has preceding relation is cyclic
ASK
WHERE {
     ?q doc:has_related_question ?child1Q .
     ?q doc:has_related_question ?child2Q .

     ?child1Q form:has-preceding-question ?child2Q .
     ?child2Q form:has-preceding-question* ?child1Q .
     FILTER(?child1Q != ?child2Q)
}""" ;
    ] ;
  kbss-module:has-output-graph-constraint [
      a sp:Ask ;
      sp:text """# 1 - has preceding question relation is reflexive
ASK
WHERE {
     ?q form:has-preceding-question ?q .
}""" ;
    ] ;
  sm:next :attach-answerable-section-logic ;
  sm:next :attach-identifier-to-section ;
  sm:next :attach-possible-values-hook ;
  sm:next :attach-relevant-tested-questions ;
  sm:next :attach-type-questions-possible-values ;
  sm:next :bind-root-question ;
  sm:next :construct-metaquestions ;
  sm:next :construct-unit-of-measure-questions ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1 - start with direct-precedence
CONSTRUCT {
    form:direct-precedence :is-processed true .
}
WHERE {

}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.2 language-variant-precedence
CONSTRUCT {
      ?currentP  :is-processed true .
}
WHERE {
     BIND(form:language-variant-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.3 realtor-multiplicity-precedence
CONSTRUCT {
      ### precedence prioritization
      ?currentP  :is-processed true .

      ### rule implementation
      ?q2 form:has-preceding-question  ?q1 .
}
WHERE {

     ### precedence prioritization
     BIND(form:relator-multiplicity-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .


     ### rule implementation
      ?p a ?currentP  ;
                form:has-first-question ?q1 ;
                form:has-second-question ?q2 ;
      .


     ### prevent cycle condition
     FILTER NOT EXISTS {
           ?q1  form:has-preceding-question  ?q2 .
     }
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.4 meta-question-precedence
CONSTRUCT {
      ?currentP  :is-processed true .
}
WHERE {
     BIND(form:meta-question-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.5 object-identification-precedence (identification question first)
CONSTRUCT {
     ### precedence prioritization
      ?currentP  :is-processed true .

      ### rule implementation
      ?q2 form:has-preceding-question  ?q1 .
      ?q1 a form:object-identification-question .
}
WHERE {


     ### precedence prioritization
     BIND(form:object-identification-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .


     ### rule implementation
     ?q1 a doc:question .
     ?q1 form:has-question-origin ?entity .
     ?entity a ft:object-identifier-quality .
     ?qParent doc:has_related_question ?q1 .
     ?qParent doc:has_related_question ?q2 .
     ?q2 form:has-question-origin ?otherSiblingEntity .
     FILTER (?q1 != ?q2)
     FILTER NOT EXISTS {
         ?otherSiblingEntity a ft:object-identifier-quality .
     }
     FILTER NOT EXISTS {
         ?q2  :has-processed-entity ?qo.
     }


     ### prevent cycle condition
     FILTER NOT EXISTS {
          ?q1  form:has-preceding-question  ?q2 .
     }

}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.6 object-description-precedence (description question first)
CONSTRUCT {
     ### precedence prioritization
      ?currentP  :is-processed true .

      ### rule implementation
      ?q2 form:has-preceding-question  ?q1 .
      ?q1 a form:object-description-question .
}
WHERE {


     ### precedence prioritization
     BIND(form:object-description-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .


     ### rule implementation
     ?q1 a doc:question .
     ?q1 form:has-question-origin ?entity .
     ?entity a ft:object-description-quality .
     ?qParent doc:has_related_question ?q1 .
     ?qParent doc:has_related_question ?q2 .
     ?q2 form:has-question-origin ?otherSiblingEntity .
     FILTER (?q1 != ?q2)
     FILTER NOT EXISTS {
         ?otherSiblingEntity a ft:object-description-quality .
     }
     FILTER NOT EXISTS {
         ?q2  :has-processed-entity ?qo.
     }


     ### prevent cycle condition
     FILTER NOT EXISTS {
          ?q1  form:has-preceding-question  ?q2 .
     }

}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.7 aspect-type-precedence (tropes before relators)
CONSTRUCT {
      ### precedence prioritization
      ?currentP  :is-processed true .

      ### rule implementation
      ?q2 form:has-preceding-question  ?q1 .

} WHERE {

     ### precedence prioritization
     BIND(form:aspect-type-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .


     ### rule implementation
     ?q1 a form:trope-question .
     ?q2 a form:relator-question .
     ?qParent doc:has_related_question ?q1 .
     ?qParent doc:has_related_question ?q2 .
     FILTER (?q1 != ?q2)


     ### prevent cycle condition
     FILTER NOT EXISTS {
           ?q1  form:has-preceding-question  ?q2 .
     }

}
""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 1.8 temporal-precedence (earlier before later)
CONSTRUCT {
     ### precedence prioritization
      ?currentP  :is-processed true .

      ### rule implementation
      ?q2 form:has-preceding-question  ?q1 .
      ?q1 a form:temporally-related-question .
      ?q2 a form:temporally-related-question .
}
WHERE {


     ### precedence prioritization
     BIND(form:temporal-precedence as ?currentP)

     FILTER NOT EXISTS {
          ?currentP  :is-processed true .
     }

     ?currentP  form:has-higher-priority-precedence ?previousP .
     ?previousP  :is-processed true .


     ### rule implementation
     ?parentQ doc:has_related_question ?q1  .
     ?q1 form:has-question-origin ?earlierQO .
     ?parentQ doc:has_related_question ?q2 .
     ?q2 form:has-question-origin ?laterQO .
     ?earlierQO ft:precedes-relatively-in-time ?laterQO .


     ### prevent cycle condition
     FILTER NOT EXISTS {
          ?q1  form:has-preceding-question  ?q2 .
     }

}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 4 - make sections after regular questions
CONSTRUCT {
# TODO disabled -- make it regular rule first !
#    ?qSection form:has-preceding-question ?qSimpleSibling .
}
WHERE {
    ?qParent doc:has_related_question ?qSection .
    ?qParent doc:has_related_question ?qSimpleSibling .
    ?qSection doc:has_related_question ?qSectionChild .
     FILTER NOT EXISTS {
        ?qSection form:has-question-origin ?sectionEntity .
        ?sectionEntity a ft:object-identifier-quality .
    }
    FILTER NOT EXISTS {
        ?qSimpleSibling doc:has_related_question ?qSimpleSiblingChild .
    } .
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 5 - make relators after other types of questions TODO
CONSTRUCT {
}
WHERE {
}""" ;
    ] ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """# 7 - order section filtering question before others
CONSTRUCT {
    ?qNotFilteringQ form:has-preceding-question ?qFilteringQ .
}
WHERE {
    ?q doc:has_related_question ?qFilteringQ  .
    ?q doc:has_related_question ?qNotFilteringQ .
    ?qFilteringQ :has-processed-entity ?qo1 .
    ?qNotFilteringQ :has-processing-entity ?qo2 .
}""" ;
    ] ;
  sml:replace false ;
.
:retrieve-form-template
  a sml:ApplyConstruct ;
  sm:next :bind-root-entity ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?formMetadataServiceUrl {
        ?s ?p ?o .
    }
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-record-graph
  a sml:ApplyConstruct ;
  sm:next :bind-execution-id ;
  sm:next :bind-form-template ;
  sm:next :merge ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?recordServiceUrl {
        ?s ?p ?o .
    } .
}""" ;
    ] ;
.
:retrieve-related-datasets
  a sml:ApplyConstruct ;
  sm:next :attach-root-question ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    ?rootEntity :related-dataset ?g .
    SERVICE ?sgovServiceUrl {
        GRAPH ?g {
            ?s ?p ?o .
        } .
    }
}""" ;
    ] ;
  sml:replace true ;
.
:retrieve-sample-form
  a sml:ApplyConstruct ;
  sm:next :merge-form-metadata ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o.
}
WHERE {
    SERVICE ?sampleFormServiceUrl {
          ?s ?p ?o .
    }
}""" ;
    ] ;
  sml:replace false ;
  rdfs:label "attach-sample-form" ;
.
:retrieve-sgov
  a sml:ApplyConstruct ;
  sml:constructQuery [
      a sp:Construct ;
      sp:text """CONSTRUCT {
    ?s ?p ?o .
}
WHERE {
    SERVICE ?sgovServiceUrl {
        ?s ?p ?o .
    }
}""" ;
    ] ;
  sml:replace true ;
.
:transform
  a sm:Function ;
  sm:returnModule :transform_Return ;
  rdfs:comment "Transforms sgov related data located in ?endpointUrl with ?sourceGraphId into SForms form." ;
  rdfs:subClassOf sm:Functions ;
.
:transform_Return
  a sml:ReturnRDF ;
  sml:serialization sml:Turtle ;
.
